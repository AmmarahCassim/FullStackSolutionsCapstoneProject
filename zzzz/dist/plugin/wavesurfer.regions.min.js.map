{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///wavesurfer.regions.min.js","webpack:///webpack/bootstrap 13d1c6398860074631e7","webpack:///./src/plugin/regions.js"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","2","_classCallCheck","instance","Constructor","TypeError","value","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","Region","params","ws","_this","wavesurfer","wrapper","drawer","util","style","id","getId","start","Number","end","scrollWidth","getDuration","resize","undefined","Boolean","drag","loop","color","data","attributes","maxLength","minLength","_onRedraw","updateRender","scroll","scrollParent","scrollSpeed","scrollThreshold","bindInOut","render","on","fireEvent","element","removeChild","un","play","_this2","once","playLoop","regionEl","document","createElement","className","title","formatTime","setAttribute","attrname","position","zIndex","height","top","handleLeft","appendChild","handleRight","css","cursor","left","width","maxWidth","bindEvents","map","time","Math","floor","slice","join","pixelRatio","dur","getWidth","max","min","round","regionWidth","backgroundColor","_this3","firedIn","firedOut","onProcess","backend","_this4","addEventListener","e","preventDefault","stopPropagation","container","duration","startTime","touchId","maxScroll","updated","scrollDirection","wrapperRect","edgeScroll","scrollLeft","handleEvent","delta","onDrag","onResize","window","requestAnimationFrame","onDown","touches","targetTouches","identifier","clientWidth","getBoundingClientRect","tagName","toLowerCase","classList","contains","onUp","preventClick","onMove","oldTime","regionRect","x","right","clientX","body","removeEventListener","maxEnd","update","direction","RegionsPlugin","_this5","getOwnPropertyNames","Observer","forEach","list","_onReady","regions","region","add","dragSelection","enableDragSelection","deferInit","initRegions","console","warn","initPlugin","addRegion","options","initialisedPluginList","clearRegions","clear","disableDragSelection","isReady","_this6","_this7","keys","remove","_this8","slop","pxMove","eventDown","eventUp","eventMove","_this9","getCurrentTime","cur","default"],"mappings":";;;;;CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,OAAA,aAAAH,GACA,gBAAAC,SACAA,QAAA,QAAAD,KAEAD,EAAA,WAAAA,EAAA,eAA+CA,EAAA,mBAAAC,MAC9C,mBAAAK,WAAAC,KAAA,WACD,MCKgB,UAAUC,GCX1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAR,OAGA,IAAAC,GAAAQ,EAAAD,IACAE,EAAAF,EACAG,GAAA,EACAX,WAUA,OANAM,GAAAE,GAAAI,KAAAX,EAAAD,QAAAC,IAAAD,QAAAO,GAGAN,EAAAU,GAAA,EAGAV,EAAAD,QAvBA,GAAAS,KA4DA,OAhCAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,SAAAf,EAAAgB,EAAAC,GACAV,EAAAW,EAAAlB,EAAAgB,IACAG,OAAAC,eAAApB,EAAAgB,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAV,EAAAiB,EAAA,SAAAvB,GACA,GAAAgB,GAAAhB,KAAAwB,WACA,WAA2B,MAAAxB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAM,GAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAjB,KAAAc,EAAAC,IAGtDpB,EAAAuB,EAAA,8BAGAvB,IAAAwB,EAAA,KDqBMC,EACA,SAAU/B,EAAQD,EAASO,GAEjC,YASA,SAAS0B,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCANhHjB,OAAOC,eAAepB,EAAS,cAC3BqC,OAAO,GAGX,IAAIC,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAI/B,GAAI,EAAGA,EAAI+B,EAAMC,OAAQhC,IAAK,CAAE,GAAIiC,GAAaF,EAAM/B,EAAIiC,GAAWrB,WAAaqB,EAAWrB,aAAc,EAAOqB,EAAWtB,cAAe,EAAU,SAAWsB,KAAYA,EAAWC,UAAW,GAAMzB,OAAOC,eAAeoB,EAAQG,EAAWE,IAAKF,IAAiB,MAAO,UAAUR,EAAaW,EAAYC,GAAiJ,MAA9HD,IAAYP,EAAiBJ,EAAYP,UAAWkB,GAAiBC,GAAaR,EAAiBJ,EAAaY,GAAqBZ,MEpF1hBa,EFgGO,WE/FT,QAAAA,GAAYC,EAAQC,GAAI,GAAAC,GAAA9C,IAAA4B,GAAA5B,KAAA2C,GACpB3C,KAAK+C,WAAaF,EAClB7C,KAAKgD,QAAUH,EAAGI,OAAOD,QACzBhD,KAAKkD,KAAOL,EAAGK,KACflD,KAAKmD,MAAQnD,KAAKkD,KAAKC,MAEvBnD,KAAKoD,GAAkB,MAAbR,EAAOQ,GAAaP,EAAGK,KAAKG,QAAUT,EAAOQ,GACvDpD,KAAKsD,MAAQC,OAAOX,EAAOU,QAAU,EACrCtD,KAAKwD,IACa,MAAdZ,EAAOY,IAEDxD,KAAKsD,MACL,EAAItD,KAAKgD,QAAQS,YAAczD,KAAK+C,WAAWW,cAC/CH,OAAOX,EAAOY,KACxBxD,KAAK2D,WACiBC,KAAlBhB,EAAOe,QAA8BE,QAAQjB,EAAOe,QACxD3D,KAAK8D,SAAuBF,KAAhBhB,EAAOkB,MAA4BD,QAAQjB,EAAOkB,MAC9D9D,KAAK+D,KAAOF,QAAQjB,EAAOmB,MAC3B/D,KAAKgE,MAAQpB,EAAOoB,OAAS,qBAC7BhE,KAAKiE,KAAOrB,EAAOqB,SACnBjE,KAAKkE,WAAatB,EAAOsB,eAEzBlE,KAAKmE,UAAYvB,EAAOuB,UACxBnE,KAAKoE,UAAYxB,EAAOwB,UACxBpE,KAAKqE,UAAY,iBAAMvB,GAAKwB,gBAE5BtE,KAAKuE,QAA2B,IAAlB3B,EAAO2B,QAAoB1B,EAAGD,OAAO4B,aACnDxE,KAAKyE,YAAc7B,EAAO6B,aAAe,EACzCzE,KAAK0E,gBAAkB9B,EAAO8B,iBAAmB,GAEjD1E,KAAK2E,YACL3E,KAAK4E,SACL5E,KAAK+C,WAAW8B,GAAG,OAAQ7E,KAAKqE,WAChCrE,KAAK+C,WAAW8B,GAAG,SAAU7E,KAAKqE,WAClCrE,KAAK+C,WAAW+B,UAAU,iBAAkB9E,MF0iBhD,MAncAiC,GAAaU,IACTH,IAAK,SACLR,MAAO,SErGJY,GACC,MAAQA,EAAOU,QACftD,KAAKsD,MAAQC,OAAOX,EAAOU,QAE3B,MAAQV,EAAOY,MACfxD,KAAKwD,IAAMD,OAAOX,EAAOY,MAEzB,MAAQZ,EAAOmB,OACf/D,KAAK+D,KAAOF,QAAQjB,EAAOmB,OAE3B,MAAQnB,EAAOoB,QACfhE,KAAKgE,MAAQpB,EAAOoB,OAEpB,MAAQpB,EAAOqB,OACfjE,KAAKiE,KAAOrB,EAAOqB,MAEnB,MAAQrB,EAAOe,SACf3D,KAAK2D,OAASE,QAAQjB,EAAOe,SAE7B,MAAQf,EAAOkB,OACf9D,KAAK8D,KAAOD,QAAQjB,EAAOkB,OAE3B,MAAQlB,EAAOuB,YACfnE,KAAKmE,UAAYZ,OAAOX,EAAOuB,YAE/B,MAAQvB,EAAOwB,YACfpE,KAAKoE,UAAYb,OAAOX,EAAOwB,YAE/B,MAAQxB,EAAOsB,aACflE,KAAKkE,WAAatB,EAAOsB,YAG7BlE,KAAKsE,eACLtE,KAAK8E,UAAU,UACf9E,KAAK+C,WAAW+B,UAAU,iBAAkB9E,SF2G5CwC,IAAK,SACLR,MAAO,WEvGHhC,KAAK+E,UACL/E,KAAKgD,QAAQgC,YAAYhF,KAAK+E,SAC9B/E,KAAK+E,QAAU,KACf/E,KAAK8E,UAAU,UACf9E,KAAK+C,WAAWkC,GAAG,OAAQjF,KAAKqE,WAChCrE,KAAK+C,WAAWkC,GAAG,SAAUjF,KAAKqE,WAClCrE,KAAK+C,WAAW+B,UAAU,iBAAkB9E,UF+GhDwC,IAAK,OACLR,MAAO,WE1GPhC,KAAK+C,WAAWmC,KAAKlF,KAAKsD,MAAOtD,KAAKwD,KACtCxD,KAAK8E,UAAU,QACf9E,KAAK+C,WAAW+B,UAAU,cAAe9E,SFiHzCwC,IAAK,WACLR,MAAO,WE9GA,GAAAmD,GAAAnF,IACPA,MAAKkF,OACLlF,KAAKoF,KAAK,MAAO,iBAAMD,GAAKE,gBFwH5B7C,IAAK,SACLR,MAAO,WEpHP,GAAMsD,GAAWC,SAASC,cAAc,SACxCF,GAASG,UAAY,oBACrBH,EAASI,MAAQ1F,KAAK2F,WAAW3F,KAAKsD,MAAOtD,KAAKwD,KAClD8B,EAASM,aAAa,UAAW5F,KAAKoD,GAEtC,KAAK,GAAMyC,KAAY7F,MAAKkE,WACxBoB,EAASM,aACL,eAAiBC,EACjB7F,KAAKkE,WAAW2B,GAIV7F,MAAKgD,QAAQS,WAS3B,IARAzD,KAAKmD,MAAMmC,GACPQ,SAAU,WACVC,OAAQ,EACRC,OAAQ,OACRC,IAAK,QAILjG,KAAK2D,OAAQ,CACb,GAAMuC,GAAaZ,EAASa,YACxBZ,SAASC,cAAc,WAErBY,EAAcd,EAASa,YACzBZ,SAASC,cAAc,UAE3BU,GAAWT,UAAY,4CACvBW,EAAYX,UAAY,yCACxB,IAAMY,IACFC,OAAQ,aACRR,SAAU,WACVS,KAAM,MACNN,IAAK,MACLO,MAAO,KACPC,SAAU,MACVT,OAAQ,OAEZhG,MAAKmD,MAAM+C,EAAYG,GACvBrG,KAAKmD,MAAMiD,EAAaC,GACxBrG,KAAKmD,MAAMiD,GACPG,KAAM,SAIdvG,KAAK+E,QAAU/E,KAAKgD,QAAQmD,YAAYb,GACxCtF,KAAKsE,eACLtE,KAAK0G,WAAWpB,MFiHhB9C,IAAK,aACLR,MAAO,SE/GAsB,EAAOE,GACd,OAAQF,GAASE,GAAOF,IAAUA,EAAOE,IACpCmD,IAAI,SAAAC,GAAA,OAEGC,KAAKC,MAAOF,EAAO,KAAQ,KAC1B,KAAOC,KAAKC,MAAMF,EAAO,KAAKG,OAAO,IACxCC,KAAK,OAEVA,KAAK,QF+GVxE,IAAK,WACLR,MAAO,WE5GP,MAAOhC,MAAK+C,WAAWE,OAAOuD,MAAQxG,KAAK+C,WAAWH,OAAOqE,cFmH7DzE,IAAK,eACLR,MAAO,WE/GP,GAAMkF,GAAMlH,KAAK+C,WAAWW,cACtB8C,EAAQxG,KAAKmH,UAmBnB,IAjBInH,KAAKsD,MAAQ,IACbtD,KAAKsD,MAAQ,EACbtD,KAAKwD,IAAMxD,KAAKwD,IAAMxD,KAAKsD,OAE3BtD,KAAKwD,IAAM0D,IACXlH,KAAKwD,IAAM0D,EACXlH,KAAKsD,MAAQ4D,GAAOlH,KAAKwD,IAAMxD,KAAKsD,QAGlB,MAAlBtD,KAAKoE,YACLpE,KAAKwD,IAAMqD,KAAKO,IAAIpH,KAAKsD,MAAQtD,KAAKoE,UAAWpE,KAAKwD,MAGpC,MAAlBxD,KAAKmE,YACLnE,KAAKwD,IAAMqD,KAAKQ,IAAIrH,KAAKsD,MAAQtD,KAAKmE,UAAWnE,KAAKwD,MAGtC,MAAhBxD,KAAK+E,QAAiB,CAGtB,GAAMwB,GAAOM,KAAKS,MAAMtH,KAAKsD,MAAQ4D,EAAMV,GACrCe,EAAcV,KAAKS,MAAMtH,KAAKwD,IAAM0D,EAAMV,GAASD,CAEzDvG,MAAKmD,MAAMnD,KAAK+E,SACZwB,KAAMA,EAAO,KACbC,MAAOe,EAAc,KACrBC,gBAAiBxH,KAAKgE,MACtBsC,OAAQtG,KAAK8D,KAAO,OAAS,WAGjC,KAAK,GAAM+B,KAAY7F,MAAKkE,WACxBlE,KAAK+E,QAAQa,aACT,eAAiBC,EACjB7F,KAAKkE,WAAW2B,GAIxB7F,MAAK+E,QAAQW,MAAQ1F,KAAK2F,WAAW3F,KAAKsD,MAAOtD,KAAKwD,SFoH1DhB,IAAK,YACLR,MAAO,WEhHC,GAAAyF,GAAAzH,IACRA,MAAK0H,SAAU,EACf1H,KAAK2H,UAAW,CAEhB,IAAMC,GAAY,SAAAhB,IAETa,EAAKE,UACNF,EAAKC,UACJD,EAAKnE,OAASuD,KAAKS,MAAa,IAAPV,GAAc,KACpCa,EAAKjE,KAAOqD,KAAKS,MAAa,IAAPV,GAAc,OAEzCa,EAAKE,UAAW,EAChBF,EAAKC,SAAU,EACfD,EAAK3C,UAAU,OACf2C,EAAK1E,WAAW+B,UAAU,aAA1B2C,KAECA,EAAKC,SAAWD,EAAKnE,OAASsD,GAAQa,EAAKjE,IAAMoD,IAClDa,EAAKC,SAAU,EACfD,EAAKE,UAAW,EAChBF,EAAK3C,UAAU,MACf2C,EAAK1E,WAAW+B,UAAU,YAA1B2C,IAIRzH,MAAK+C,WAAW8E,QAAQhD,GAAG,eAAgB+C,GAE3C5H,KAAK6E,GAAG,SAAU,WACd4C,EAAK1E,WAAW8E,QAAQ5C,GAAG,eAAgB2C,KAI/C5H,KAAK6E,GAAG,MAAO,WACP4C,EAAK1D,MACL0D,EAAK1E,WAAWmC,KAAKuC,EAAKnE,YFqHlCd,IAAK,aACLR,MAAO,WEhHE,GAAA8F,GAAA9H,IACTA,MAAK+E,QAAQgD,iBAAiB,aAAc,SAAAC,GACxCF,EAAKhD,UAAU,aAAckD,GAC7BF,EAAK/E,WAAW+B,UAAU,oBAA1BgD,EAAqDE,KAGzDhI,KAAK+E,QAAQgD,iBAAiB,aAAc,SAAAC,GACxCF,EAAKhD,UAAU,aAAckD,GAC7BF,EAAK/E,WAAW+B,UAAU,oBAA1BgD,EAAqDE,KAGzDhI,KAAK+E,QAAQgD,iBAAiB,QAAS,SAAAC,GACnCA,EAAEC,iBACFH,EAAKhD,UAAU,QAASkD,GACxBF,EAAK/E,WAAW+B,UAAU,eAA1BgD,EAAgDE,KAGpDhI,KAAK+E,QAAQgD,iBAAiB,WAAY,SAAAC,GACtCA,EAAEE,kBACFF,EAAEC,iBACFH,EAAKhD,UAAU,WAAYkD,GAC3BF,EAAK/E,WAAW+B,UAAU,kBAA1BgD,EAAmDE,MAItDhI,KAAK8D,MAAQ9D,KAAK2D,SACd,WACG,GAAMwE,GAAYL,EAAK/E,WAAWE,OAAOkF,UACnCC,EAAWN,EAAK/E,WAAWW,cAC3Be,EAAcqD,EAAKrD,YACnBC,EAAkBoD,EAAKpD,gBACzB2D,SACAC,SACAxE,SACAyE,SACA5E,SACA6E,GAAU,EACVC,SACAC,SAGEC,EAAa,QAAbA,GAAaX,GACf,GAAKS,IAAqB3E,GAASH,GAAnC,CAKA,GAAIiF,GACAd,EAAK9E,QAAQ4F,WAAanE,EAAcgE,CAC5CX,GAAK9E,QAAQ4F,WAAaA,EAAa/B,KAAKQ,IACxCkB,EACA1B,KAAKO,IAAI,EAAGwB,GAIhB,IAAMhC,GACFkB,EAAK/E,WAAWE,OAAO4F,YAAYb,GAAKI,EACtCU,EAAQlC,EAAOyB,CACrBA,GAAYzB,EAGZ9C,EAAOgE,EAAKiB,OAAOD,GAAShB,EAAKkB,SAASF,EAAOnF,GAGjDsF,OAAOC,sBAAsB,WACzBP,EAAWX,OAIbmB,EAAS,SAAAnB,GACPA,EAAEoB,SAAWpB,EAAEoB,QAAQ/G,OAAS,IAGpCiG,EAAUN,EAAEqB,cACNrB,EAAEqB,cAAc,GAAGC,WACnB,KAENtB,EAAEE,kBACFG,EACIP,EAAK/E,WAAWE,OAAO4F,YAAYb,GAAG,GAAQI,EAGlDG,EACIT,EAAK9E,QAAQS,YAAcqE,EAAK9E,QAAQuG,YAC5Cb,EAAcZ,EAAK9E,QAAQwG,wBAEW,UAAlCxB,EAAE7F,OAAOsH,QAAQC,cAMb/F,EAJAqE,EAAE7F,OAAOwH,UAAUC,SACf,2BAGK,QAEA,OAGb9F,GAAO,EACPH,GAAS,KAGXkG,EAAO,SAAA7B,GACLA,EAAEoB,SAAWpB,EAAEoB,QAAQ/G,OAAS,KAIhCyB,GAAQH,KACRG,GAAO,EACP2E,EAAkB,KAClB9E,GAAS,GAGT6E,IACAA,GAAU,EACVV,EAAK5E,KAAK4G,eACVhC,EAAKhD,UAAU,aAAckD,GAC7BF,EAAK/E,WAAW+B,UAAU,oBAA1BgD,EAAqDE,MAGvD+B,EAAS,SAAA/B,GACX,KAAIA,EAAEoB,SAAWpB,EAAEoB,QAAQ/G,OAAS,MAIhC2F,EAAEqB,eACFrB,EAAEqB,cAAc,GAAGC,YAAchB,KAKjCxE,GAAQH,GAAQ,CAChB,GAAMqG,GAAU3B,EACVzB,EACFkB,EAAK/E,WAAWE,OAAO4F,YAAYb,GAAKI,EACtCU,EAAQlC,EAAOyB,CAerB,IAdAA,EAAYzB,EAGRkB,EAAKhE,MAAQA,IACb0E,EAAUA,KAAaM,EACvBhB,EAAKiB,OAAOD,IAIZhB,EAAKnE,QAAUA,IACf6E,EAAUA,KAAaM,EACvBhB,EAAKkB,SAASF,EAAOnF,IAIrBmE,EAAKvD,QACL4D,EAAUoB,YAAczB,EAAK9E,QAAQS,YACvC,CACE,GAAIK,EAAM,CAGN,GAAMmG,GAAanC,EAAK/C,QAAQyE,wBAC5BU,EAAID,EAAW1D,KAAOmC,EAAYnC,IAGlCK,GAAOoD,GAAWE,GAAK,EACvBzB,GAAmB,EAEnB7B,EAAOoD,GACPE,EAAID,EAAWzD,OAASkC,EAAYyB,QAEpC1B,EAAkB,KAKI,IAArBA,GACGyB,EAAIxF,GACa,IAApB+D,GACGyB,EAAID,EAAWzD,MACXkC,EAAYyB,MAAQzF,KAE5B+D,EAAkB,UAEnB,CAEH,GAAIyB,GAAIlC,EAAEoC,QAAU1B,EAAYnC,IAI5BkC,GADAyB,GAAKxF,GACc,EAEnBwF,GACAxB,EAAYyB,MAAQzF,EAEF,EAEA,KAI1B+D,GAAmBE,EAAWX,KAK1CF,GAAK/C,QAAQgD,iBAAiB,YAAaoB,GAC3CrB,EAAK/C,QAAQgD,iBAAiB,aAAcoB,GAE5CrB,EAAK9E,QAAQ+E,iBAAiB,YAAagC,GAC3CjC,EAAK9E,QAAQ+E,iBAAiB,YAAagC,GAE3CxE,SAAS8E,KAAKtC,iBAAiB,UAAW8B,GAC1CtE,SAAS8E,KAAKtC,iBAAiB,WAAY8B,GAE3C/B,EAAKjD,GAAG,SAAU,WACdU,SAAS8E,KAAKC,oBAAoB,UAAWT,GAC7CtE,SAAS8E,KAAKC,oBAAoB,WAAYT,GAC9C/B,EAAK9E,QAAQsH,oBAAoB,YAAaP,GAC9CjC,EAAK9E,QAAQsH,oBAAoB,YAAaP,KAGlDjC,EAAK/E,WAAW8B,GAAG,UAAW,WAC1BU,SAAS8E,KAAKC,oBAAoB,UAAWT,GAC7CtE,SAAS8E,KAAKC,oBAAoB,WAAYT,WFsF1DrH,IAAK,SACLR,MAAO,SElFJ8G,GACH,GAAMyB,GAASvK,KAAK+C,WAAWW,aAC3B1D,MAAKwD,IAAMsF,EAAQyB,GAAUvK,KAAKsD,MAAQwF,EAAQ,GAItD9I,KAAKwK,QACDlH,MAAOtD,KAAKsD,MAAQwF,EACpBtF,IAAKxD,KAAKwD,IAAMsF,OFsFpBtG,IAAK,WACLR,MAAO,SEnFF8G,EAAO2B,GACK,SAAbA,EACAzK,KAAKwK,QACDlH,MAAOuD,KAAKQ,IAAIrH,KAAKsD,MAAQwF,EAAO9I,KAAKwD,KACzCA,IAAKqD,KAAKO,IAAIpH,KAAKsD,MAAQwF,EAAO9I,KAAKwD,OAG3CxD,KAAKwK,QACDlH,MAAOuD,KAAKQ,IAAIrH,KAAKwD,IAAMsF,EAAO9I,KAAKsD,OACvCE,IAAKqD,KAAKO,IAAIpH,KAAKwD,IAAMsF,EAAO9I,KAAKsD,aFyF1CX,KE7BU+H,EFwFD,WEvChB,QAAAA,GAAY9H,EAAQC,GAAI,GAAA8H,GAAA3K,IAAA4B,GAAA5B,KAAA0K,GACpB1K,KAAK4C,OAASA,EACd5C,KAAK+C,WAAaF,EAClB7C,KAAKkD,KAAOL,EAAGK,KAGepC,OAAO8J,oBACjC5K,KAAKkD,KAAK2H,SAAStJ,WAEDuJ,QAAQ,SAAAtI,GAC1BG,EAAOpB,UAAUiB,GAAOmI,EAAKzH,KAAK2H,SAAStJ,UAAUiB,KAEzDxC,KAAK+C,WAAWJ,OAASA,EAGzB3C,KAAK+K,QACL/K,KAAKgL,SAAW,WACZL,EAAK3H,QAAU2H,EAAK5H,WAAWE,OAAOD,QAClC2H,EAAK/H,OAAOqI,SACZN,EAAK/H,OAAOqI,QAAQH,QAAQ,SAAAI,GACxBP,EAAKQ,IAAID,KAGbP,EAAK/H,OAAOwI,eACZT,EAAKU,oBAAoBV,EAAK/H,SFwT1C,MAxSAX,GAAayI,EAAe,OACxBlI,IAAK,SAWLR,MAAO,SE3FGY,GACV,OACIjC,KAAM,UACN2K,aAAW1I,IAAUA,EAAO0I,YAAY1I,EAAO0I,UAC/C1I,OAAQA,EACRF,aACI6I,YADS,WAELC,QAAQC,KACJ,0EAEJzL,KAAK0L,WAAW,YAGpBC,UARS,SAQCC,GAIN,MAHK5L,MAAK6L,sBAAsBZ,SAC5BjL,KAAK0L,WAAW,WAEb1L,KAAKiL,QAAQE,IAAIS,IAG5BE,aAfS,WAgBL9L,KAAKiL,SAAWjL,KAAKiL,QAAQc,SAGjCV,oBAnBS,SAmBWO,GACX5L,KAAK6L,sBAAsBZ,SAC5BjL,KAAK0L,WAAW,WAEpB1L,KAAKiL,QAAQI,oBAAoBO,IAGrCI,qBA1BS,WA2BLhM,KAAKiL,QAAQe,yBAGrBnK,SAAU6I,OFyHlBzI,EAAayI,IACTlI,IAAK,OACLR,MAAO,WExFHhC,KAAK+C,WAAWkJ,SAChBjM,KAAKgL,WAEThL,KAAK+C,WAAW8B,GAAG,QAAS7E,KAAKgL,aF6FjCxI,IAAK,UACLR,MAAO,WE1FPhC,KAAK+C,WAAWkC,GAAG,QAASjF,KAAKgL,UACjChL,KAAKgM,uBACLhM,KAAK+L,WFgGLvJ,IAAK,MACLR,MAAO,SE9FPY,GAAQ,GAAAsJ,GAAAlM,KACFkL,EAAS,GAAIlL,MAAK+C,WAAWJ,OAAOC,EAAQ5C,KAAK+C,WAQvD,OANA/C,MAAK+K,KAAKG,EAAO9H,IAAM8H,EAEvBA,EAAOrG,GAAG,SAAU,iBACTqH,GAAKnB,KAAKG,EAAO9H,MAGrB8H,KFsGP1I,IAAK,QACLR,MAAO,WEnGH,GAAAmK,GAAAnM,IACJc,QAAOsL,KAAKpM,KAAK+K,MAAMD,QAAQ,SAAA1H,GAC3B+I,EAAKpB,KAAK3H,GAAIiJ,cFyGlB7J,IAAK,sBACLR,MAAO,SEtGSY,GAAQ,GAAA0J,GAAAtM,KAClBuM,EAAO3J,EAAO2J,MAAQ,EACtBpE,EAAYnI,KAAK+C,WAAWE,OAAOkF,UACnC5D,GACgB,IAAlB3B,EAAO2B,QAAoBvE,KAAK+C,WAAWH,OAAO4B,aAChDC,EAAc7B,EAAO6B,aAAe,EACpCC,EAAkB9B,EAAO8B,iBAAmB,GAC9CZ,SACAsE,EAAWpI,KAAK+C,WAAWW,cAC3B6E,SACAjF,SACA4H,SACA5C,SACAkE,EAAS,EACT/D,SACAC,SAGEC,EAAa,QAAbA,GAAaX,GACf,GAAKkD,GAAWzC,EAAhB,CAKA,GAAIG,GACA0D,EAAKtJ,QAAQ4F,WAAanE,EAAcgE,CAC5C6D,GAAKtJ,QAAQ4F,WAAaA,EAAa/B,KAAKQ,IACxCkB,EACA1B,KAAKO,IAAI,EAAGwB,GAIhB,IAAMpF,GAAM8I,EAAKvJ,WAAWE,OAAO4F,YAAYb,EAC/CkD,GAAOV,QACHlH,MAAOuD,KAAKQ,IAAI7D,EAAM4E,EAAU9E,EAAQ8E,GACxC5E,IAAKqD,KAAKO,IAAI5D,EAAM4E,EAAU9E,EAAQ8E,KAItCQ,EAAaL,GAAaK,EAAa,GACvCK,OAAOC,sBAAsB,WACzBP,EAAWX,OAKjByE,EAAY,SAAAzE,GACVA,EAAEoB,SAAWpB,EAAEoB,QAAQ/G,OAAS,IAGpC+F,EAAWkE,EAAKvJ,WAAWW,cAC3B4E,EAAUN,EAAEqB,cAAgBrB,EAAEqB,cAAc,GAAGC,WAAa,KAG5Df,EAAY+D,EAAKtJ,QAAQS,YAAc6I,EAAKtJ,QAAQuG,YACpDb,EAAc4D,EAAKtJ,QAAQwG,wBAE3B1F,GAAO,EACPR,EAAQgJ,EAAKvJ,WAAWE,OAAO4F,YAAYb,GAAG,GAC9CkD,EAAS,KACTzC,EAAkB,MAEtBzI,MAAKgD,QAAQ+E,iBAAiB,YAAa0E,GAC3CzM,KAAKgD,QAAQ+E,iBAAiB,aAAc0E,GAC5CzM,KAAK6E,GAAG,yBAA0B,WAC9ByH,EAAKtJ,QAAQsH,oBAAoB,aAAcmC,GAC/CH,EAAKtJ,QAAQsH,oBAAoB,YAAamC,IAGlD,IAAMC,GAAU,SAAA1E,GACRA,EAAEoB,SAAWpB,EAAEoB,QAAQ/G,OAAS,IAIpCyB,GAAO,EACP0I,EAAS,EACT/D,EAAkB,KAEdyC,IACAoB,EAAKpJ,KAAK4G,eACVoB,EAAOpG,UAAU,aAAckD,GAC/BsE,EAAKvJ,WAAW+B,UAAU,oBAAqBoG,EAAQlD,IAG3DkD,EAAS,MAEblL,MAAKgD,QAAQ+E,iBAAiB,UAAW2E,GACzC1M,KAAKgD,QAAQ+E,iBAAiB,WAAY2E,GAE1CnH,SAAS8E,KAAKtC,iBAAiB,UAAW2E,GAC1CnH,SAAS8E,KAAKtC,iBAAiB,WAAY2E,GAC3C1M,KAAK6E,GAAG,yBAA0B,WAC9BU,SAAS8E,KAAKC,oBAAoB,UAAWoC,GAC7CnH,SAAS8E,KAAKC,oBAAoB,WAAYoC,GAC9CJ,EAAKtJ,QAAQsH,oBAAoB,WAAYoC,GAC7CJ,EAAKtJ,QAAQsH,oBAAoB,UAAWoC,IAGhD,IAAMC,GAAY,SAAA3E,GACd,GAAKlE,OAGC0I,GAAUD,GAIZvE,EAAEoB,SAAWpB,EAAEoB,QAAQ/G,OAAS,GAGhC2F,EAAEqB,eAAiBrB,EAAEqB,cAAc,GAAGC,YAAchB,GAAxD,CAIK4C,IACDA,EAASoB,EAAKnB,IAAIvI,OAGtB,IAAMY,GAAM8I,EAAKvJ,WAAWE,OAAO4F,YAAYb,EAO/C,IANAkD,EAAOV,QACHlH,MAAOuD,KAAKQ,IAAI7D,EAAM4E,EAAU9E,EAAQ8E,GACxC5E,IAAKqD,KAAKO,IAAI5D,EAAM4E,EAAU9E,EAAQ8E,KAItC7D,GAAU4D,EAAUoB,YAAc+C,EAAKtJ,QAAQS,YAAa,CAE5D,GAAMyG,GAAIlC,EAAEoC,QAAU1B,EAAYnC,IAE9BkC,GADAyB,GAAKxF,GACc,EACZwF,GAAKxB,EAAYyB,MAAQzF,EACd,EAEA,KAEtB+D,GAAmBE,EAAWX,KAGtChI,MAAKgD,QAAQ+E,iBAAiB,YAAa4E,GAC3C3M,KAAKgD,QAAQ+E,iBAAiB,YAAa4E,GAC3C3M,KAAK6E,GAAG,yBAA0B,WAC9ByH,EAAKtJ,QAAQsH,oBAAoB,YAAaqC,GAC9CL,EAAKtJ,QAAQsH,oBAAoB,YAAaqC,QFuGlDnK,IAAK,uBACLR,MAAO,WEnGPhC,KAAK8E,UAAU,6BF6GftC,IAAK,mBACLR,MAAO,WEvGQ,GAAA4K,GAAA5M,KACT4G,EAAO5G,KAAK+C,WAAW8J,iBACzBxF,EAAM,IAUV,OATAvG,QAAOsL,KAAKpM,KAAK+K,MAAMD,QAAQ,SAAA1H,GAC3B,GAAM0J,GAAMF,EAAK7B,KAAK3H,EAClB0J,GAAIxJ,OAASsD,GAAQkG,EAAItJ,KAAOoD,KAC3BS,GAAOyF,EAAItJ,IAAMsJ,EAAIxJ,MAAQ+D,EAAI7D,IAAM6D,EAAI/D,SAC5C+D,EAAMyF,KAKXzF,MF6GJqD,IAGX/K,GAAQoN,QEpYarC,EFqYrB9K,EAAOD,QAAUA,EAAiB","file":"wavesurfer.regions.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"regions\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"regions\"] = factory();\n\telse\n\t\troot[\"WaveSurfer\"] = root[\"WaveSurfer\"] || {}, root[\"WaveSurfer\"][\"regions\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*!\n * wavesurfer.js 2.0.5 (Tue Mar 27 2018 22:41:46 GMT+0200 (SAST))\n * https://github.com/katspaugh/wavesurfer.js\n * @license BSD-3-Clause\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"regions\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"regions\"] = factory();\n\telse\n\t\troot[\"WaveSurfer\"] = root[\"WaveSurfer\"] || {}, root[\"WaveSurfer\"][\"regions\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"localhost:8080/dist/plugin/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 2:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * (Single) Region plugin class\n *\n * Must be turned into an observer before instantiating. This is done in\n * RegionsPlugin (main plugin class)\n *\n * @extends {Observer}\n */\nvar Region = function () {\n    function Region(params, ws) {\n        var _this = this;\n\n        _classCallCheck(this, Region);\n\n        this.wavesurfer = ws;\n        this.wrapper = ws.drawer.wrapper;\n        this.util = ws.util;\n        this.style = this.util.style;\n\n        this.id = params.id == null ? ws.util.getId() : params.id;\n        this.start = Number(params.start) || 0;\n        this.end = params.end == null ? // small marker-like region\n        this.start + 4 / this.wrapper.scrollWidth * this.wavesurfer.getDuration() : Number(params.end);\n        this.resize = params.resize === undefined ? true : Boolean(params.resize);\n        this.drag = params.drag === undefined ? true : Boolean(params.drag);\n        this.loop = Boolean(params.loop);\n        this.color = params.color || 'rgba(0, 0, 0, 0.1)';\n        this.data = params.data || {};\n        this.attributes = params.attributes || {};\n\n        this.maxLength = params.maxLength;\n        this.minLength = params.minLength;\n        this._onRedraw = function () {\n            return _this.updateRender();\n        };\n\n        this.scroll = params.scroll !== false && ws.params.scrollParent;\n        this.scrollSpeed = params.scrollSpeed || 1;\n        this.scrollThreshold = params.scrollThreshold || 10;\n\n        this.bindInOut();\n        this.render();\n        this.wavesurfer.on('zoom', this._onRedraw);\n        this.wavesurfer.on('redraw', this._onRedraw);\n        this.wavesurfer.fireEvent('region-created', this);\n    }\n\n    /* Update region params. */\n\n\n    _createClass(Region, [{\n        key: 'update',\n        value: function update(params) {\n            if (null != params.start) {\n                this.start = Number(params.start);\n            }\n            if (null != params.end) {\n                this.end = Number(params.end);\n            }\n            if (null != params.loop) {\n                this.loop = Boolean(params.loop);\n            }\n            if (null != params.color) {\n                this.color = params.color;\n            }\n            if (null != params.data) {\n                this.data = params.data;\n            }\n            if (null != params.resize) {\n                this.resize = Boolean(params.resize);\n            }\n            if (null != params.drag) {\n                this.drag = Boolean(params.drag);\n            }\n            if (null != params.maxLength) {\n                this.maxLength = Number(params.maxLength);\n            }\n            if (null != params.minLength) {\n                this.minLength = Number(params.minLength);\n            }\n            if (null != params.attributes) {\n                this.attributes = params.attributes;\n            }\n\n            this.updateRender();\n            this.fireEvent('update');\n            this.wavesurfer.fireEvent('region-updated', this);\n        }\n\n        /* Remove a single region. */\n\n    }, {\n        key: 'remove',\n        value: function remove() {\n            if (this.element) {\n                this.wrapper.removeChild(this.element);\n                this.element = null;\n                this.fireEvent('remove');\n                this.wavesurfer.un('zoom', this._onRedraw);\n                this.wavesurfer.un('redraw', this._onRedraw);\n                this.wavesurfer.fireEvent('region-removed', this);\n            }\n        }\n\n        /* Play the audio region. */\n\n    }, {\n        key: 'play',\n        value: function play() {\n            this.wavesurfer.play(this.start, this.end);\n            this.fireEvent('play');\n            this.wavesurfer.fireEvent('region-play', this);\n        }\n\n        /* Play the region in loop. */\n\n    }, {\n        key: 'playLoop',\n        value: function playLoop() {\n            var _this2 = this;\n\n            this.play();\n            this.once('out', function () {\n                return _this2.playLoop();\n            });\n        }\n\n        /* Render a region as a DOM element. */\n\n    }, {\n        key: 'render',\n        value: function render() {\n            var regionEl = document.createElement('region');\n            regionEl.className = 'wavesurfer-region';\n            regionEl.title = this.formatTime(this.start, this.end);\n            regionEl.setAttribute('data-id', this.id);\n\n            for (var attrname in this.attributes) {\n                regionEl.setAttribute('data-region-' + attrname, this.attributes[attrname]);\n            }\n\n            var width = this.wrapper.scrollWidth;\n            this.style(regionEl, {\n                position: 'absolute',\n                zIndex: 2,\n                height: '100%',\n                top: '0px'\n            });\n\n            /* Resize handles */\n            if (this.resize) {\n                var handleLeft = regionEl.appendChild(document.createElement('handle'));\n                var handleRight = regionEl.appendChild(document.createElement('handle'));\n                handleLeft.className = 'wavesurfer-handle wavesurfer-handle-start';\n                handleRight.className = 'wavesurfer-handle wavesurfer-handle-end';\n                var css = {\n                    cursor: 'col-resize',\n                    position: 'absolute',\n                    left: '0px',\n                    top: '0px',\n                    width: '1%',\n                    maxWidth: '4px',\n                    height: '100%'\n                };\n                this.style(handleLeft, css);\n                this.style(handleRight, css);\n                this.style(handleRight, {\n                    left: '100%'\n                });\n            }\n\n            this.element = this.wrapper.appendChild(regionEl);\n            this.updateRender();\n            this.bindEvents(regionEl);\n        }\n    }, {\n        key: 'formatTime',\n        value: function formatTime(start, end) {\n            return (start == end ? [start] : [start, end]).map(function (time) {\n                return [Math.floor(time % 3600 / 60), // minutes\n                ('00' + Math.floor(time % 60)).slice(-2) // seconds\n                ].join(':');\n            }).join('-');\n        }\n    }, {\n        key: 'getWidth',\n        value: function getWidth() {\n            return this.wavesurfer.drawer.width / this.wavesurfer.params.pixelRatio;\n        }\n\n        /* Update element's position, width, color. */\n\n    }, {\n        key: 'updateRender',\n        value: function updateRender() {\n            var dur = this.wavesurfer.getDuration();\n            var width = this.getWidth();\n\n            if (this.start < 0) {\n                this.start = 0;\n                this.end = this.end - this.start;\n            }\n            if (this.end > dur) {\n                this.end = dur;\n                this.start = dur - (this.end - this.start);\n            }\n\n            if (this.minLength != null) {\n                this.end = Math.max(this.start + this.minLength, this.end);\n            }\n\n            if (this.maxLength != null) {\n                this.end = Math.min(this.start + this.maxLength, this.end);\n            }\n\n            if (this.element != null) {\n                // Calculate the left and width values of the region such that\n                // no gaps appear between regions.\n                var left = Math.round(this.start / dur * width);\n                var regionWidth = Math.round(this.end / dur * width) - left;\n\n                this.style(this.element, {\n                    left: left + 'px',\n                    width: regionWidth + 'px',\n                    backgroundColor: this.color,\n                    cursor: this.drag ? 'move' : 'default'\n                });\n\n                for (var attrname in this.attributes) {\n                    this.element.setAttribute('data-region-' + attrname, this.attributes[attrname]);\n                }\n\n                this.element.title = this.formatTime(this.start, this.end);\n            }\n        }\n\n        /* Bind audio events. */\n\n    }, {\n        key: 'bindInOut',\n        value: function bindInOut() {\n            var _this3 = this;\n\n            this.firedIn = false;\n            this.firedOut = false;\n\n            var onProcess = function onProcess(time) {\n                if (!_this3.firedOut && _this3.firedIn && (_this3.start >= Math.round(time * 100) / 100 || _this3.end <= Math.round(time * 100) / 100)) {\n                    _this3.firedOut = true;\n                    _this3.firedIn = false;\n                    _this3.fireEvent('out');\n                    _this3.wavesurfer.fireEvent('region-out', _this3);\n                }\n                if (!_this3.firedIn && _this3.start <= time && _this3.end > time) {\n                    _this3.firedIn = true;\n                    _this3.firedOut = false;\n                    _this3.fireEvent('in');\n                    _this3.wavesurfer.fireEvent('region-in', _this3);\n                }\n            };\n\n            this.wavesurfer.backend.on('audioprocess', onProcess);\n\n            this.on('remove', function () {\n                _this3.wavesurfer.backend.un('audioprocess', onProcess);\n            });\n\n            /* Loop playback. */\n            this.on('out', function () {\n                if (_this3.loop) {\n                    _this3.wavesurfer.play(_this3.start);\n                }\n            });\n        }\n\n        /* Bind DOM events. */\n\n    }, {\n        key: 'bindEvents',\n        value: function bindEvents() {\n            var _this4 = this;\n\n            this.element.addEventListener('mouseenter', function (e) {\n                _this4.fireEvent('mouseenter', e);\n                _this4.wavesurfer.fireEvent('region-mouseenter', _this4, e);\n            });\n\n            this.element.addEventListener('mouseleave', function (e) {\n                _this4.fireEvent('mouseleave', e);\n                _this4.wavesurfer.fireEvent('region-mouseleave', _this4, e);\n            });\n\n            this.element.addEventListener('click', function (e) {\n                e.preventDefault();\n                _this4.fireEvent('click', e);\n                _this4.wavesurfer.fireEvent('region-click', _this4, e);\n            });\n\n            this.element.addEventListener('dblclick', function (e) {\n                e.stopPropagation();\n                e.preventDefault();\n                _this4.fireEvent('dblclick', e);\n                _this4.wavesurfer.fireEvent('region-dblclick', _this4, e);\n            });\n\n            /* Drag or resize on mousemove. */\n            (this.drag || this.resize) && function () {\n                var container = _this4.wavesurfer.drawer.container;\n                var duration = _this4.wavesurfer.getDuration();\n                var scrollSpeed = _this4.scrollSpeed;\n                var scrollThreshold = _this4.scrollThreshold;\n                var startTime = void 0;\n                var touchId = void 0;\n                var drag = void 0;\n                var maxScroll = void 0;\n                var resize = void 0;\n                var updated = false;\n                var scrollDirection = void 0;\n                var wrapperRect = void 0;\n\n                // Scroll when the user is dragging within the threshold\n                var edgeScroll = function edgeScroll(e) {\n                    if (!scrollDirection || !drag && !resize) {\n                        return;\n                    }\n\n                    // Update scroll position\n                    var scrollLeft = _this4.wrapper.scrollLeft + scrollSpeed * scrollDirection;\n                    _this4.wrapper.scrollLeft = scrollLeft = Math.min(maxScroll, Math.max(0, scrollLeft));\n\n                    // Update time\n                    var time = _this4.wavesurfer.drawer.handleEvent(e) * duration;\n                    var delta = time - startTime;\n                    startTime = time;\n\n                    // Continue dragging or resizing\n                    drag ? _this4.onDrag(delta) : _this4.onResize(delta, resize);\n\n                    // Repeat\n                    window.requestAnimationFrame(function () {\n                        edgeScroll(e);\n                    });\n                };\n\n                var onDown = function onDown(e) {\n                    if (e.touches && e.touches.length > 1) {\n                        return;\n                    }\n                    touchId = e.targetTouches ? e.targetTouches[0].identifier : null;\n\n                    e.stopPropagation();\n                    startTime = _this4.wavesurfer.drawer.handleEvent(e, true) * duration;\n\n                    // Store for scroll calculations\n                    maxScroll = _this4.wrapper.scrollWidth - _this4.wrapper.clientWidth;\n                    wrapperRect = _this4.wrapper.getBoundingClientRect();\n\n                    if (e.target.tagName.toLowerCase() == 'handle') {\n                        if (e.target.classList.contains('wavesurfer-handle-start')) {\n                            resize = 'start';\n                        } else {\n                            resize = 'end';\n                        }\n                    } else {\n                        drag = true;\n                        resize = false;\n                    }\n                };\n                var onUp = function onUp(e) {\n                    if (e.touches && e.touches.length > 1) {\n                        return;\n                    }\n\n                    if (drag || resize) {\n                        drag = false;\n                        scrollDirection = null;\n                        resize = false;\n                    }\n\n                    if (updated) {\n                        updated = false;\n                        _this4.util.preventClick();\n                        _this4.fireEvent('update-end', e);\n                        _this4.wavesurfer.fireEvent('region-update-end', _this4, e);\n                    }\n                };\n                var onMove = function onMove(e) {\n                    if (e.touches && e.touches.length > 1) {\n                        return;\n                    }\n                    if (e.targetTouches && e.targetTouches[0].identifier != touchId) {\n                        return;\n                    }\n\n                    if (drag || resize) {\n                        var oldTime = startTime;\n                        var time = _this4.wavesurfer.drawer.handleEvent(e) * duration;\n                        var delta = time - startTime;\n                        startTime = time;\n\n                        // Drag\n                        if (_this4.drag && drag) {\n                            updated = updated || !!delta;\n                            _this4.onDrag(delta);\n                        }\n\n                        // Resize\n                        if (_this4.resize && resize) {\n                            updated = updated || !!delta;\n                            _this4.onResize(delta, resize);\n                        }\n\n                        if (_this4.scroll && container.clientWidth < _this4.wrapper.scrollWidth) {\n                            if (drag) {\n                                // The threshold is not between the mouse and the container edge\n                                // but is between the region and the container edge\n                                var regionRect = _this4.element.getBoundingClientRect();\n                                var x = regionRect.left - wrapperRect.left;\n\n                                // Check direction\n                                if (time < oldTime && x >= 0) {\n                                    scrollDirection = -1;\n                                } else if (time > oldTime && x + regionRect.width <= wrapperRect.right) {\n                                    scrollDirection = 1;\n                                }\n\n                                // Check that we are still beyond the threshold\n                                if (scrollDirection === -1 && x > scrollThreshold || scrollDirection === 1 && x + regionRect.width < wrapperRect.right - scrollThreshold) {\n                                    scrollDirection = null;\n                                }\n                            } else {\n                                // Mouse based threshold\n                                var _x = e.clientX - wrapperRect.left;\n\n                                // Check direction\n                                if (_x <= scrollThreshold) {\n                                    scrollDirection = -1;\n                                } else if (_x >= wrapperRect.right - scrollThreshold) {\n                                    scrollDirection = 1;\n                                } else {\n                                    scrollDirection = null;\n                                }\n                            }\n\n                            scrollDirection && edgeScroll(e);\n                        }\n                    }\n                };\n\n                _this4.element.addEventListener('mousedown', onDown);\n                _this4.element.addEventListener('touchstart', onDown);\n\n                _this4.wrapper.addEventListener('mousemove', onMove);\n                _this4.wrapper.addEventListener('touchmove', onMove);\n\n                document.body.addEventListener('mouseup', onUp);\n                document.body.addEventListener('touchend', onUp);\n\n                _this4.on('remove', function () {\n                    document.body.removeEventListener('mouseup', onUp);\n                    document.body.removeEventListener('touchend', onUp);\n                    _this4.wrapper.removeEventListener('mousemove', onMove);\n                    _this4.wrapper.removeEventListener('touchmove', onMove);\n                });\n\n                _this4.wavesurfer.on('destroy', function () {\n                    document.body.removeEventListener('mouseup', onUp);\n                    document.body.removeEventListener('touchend', onUp);\n                });\n            }();\n        }\n    }, {\n        key: 'onDrag',\n        value: function onDrag(delta) {\n            var maxEnd = this.wavesurfer.getDuration();\n            if (this.end + delta > maxEnd || this.start + delta < 0) {\n                return;\n            }\n\n            this.update({\n                start: this.start + delta,\n                end: this.end + delta\n            });\n        }\n    }, {\n        key: 'onResize',\n        value: function onResize(delta, direction) {\n            if (direction == 'start') {\n                this.update({\n                    start: Math.min(this.start + delta, this.end),\n                    end: Math.max(this.start + delta, this.end)\n                });\n            } else {\n                this.update({\n                    start: Math.min(this.end + delta, this.start),\n                    end: Math.max(this.end + delta, this.start)\n                });\n            }\n        }\n    }]);\n\n    return Region;\n}();\n\n/**\n * @typedef {Object} RegionsPluginParams\n * @property {?boolean} dragSelection Enable creating regions by dragging wih\n * the mouse\n * @property {?RegionParams[]} regions Regions that should be added upon\n * initialisation\n * @property {number} slop=2 The sensitivity of the mouse dragging\n * @property {?boolean} deferInit Set to true to manually call\n * `initPlugin('regions')`\n */\n\n/**\n * @typedef {Object} RegionParams\n * @desc The parameters used to describe a region.\n * @example wavesurfer.addRegion(regionParams);\n * @property {string} id=â†’random The id of the region\n * @property {number} start=0 The start position of the region (in seconds).\n * @property {number} end=0 The end position of the region (in seconds).\n * @property {?boolean} loop Whether to loop the region when played back.\n * @property {boolean} drag=true Allow/dissallow dragging the region.\n * @property {boolean} resize=true Allow/dissallow resizing the region.\n * @property {string} [color='rgba(0, 0, 0, 0.1)'] HTML color code.\n */\n\n/**\n * Regions are visual overlays on waveform that can be used to play and loop\n * portions of audio. Regions can be dragged and resized.\n *\n * Visual customization is possible via CSS (using the selectors\n * `.wavesurfer-region` and `.wavesurfer-handle`).\n *\n * @implements {PluginClass}\n * @extends {Observer}\n *\n * @example\n * // es6\n * import RegionsPlugin from 'wavesurfer.regions.js';\n *\n * // commonjs\n * var RegionsPlugin = require('wavesurfer.regions.js');\n *\n * // if you are using <script> tags\n * var RegionsPlugin = window.WaveSurfer.regions;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     RegionsPlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\n\n\nvar RegionsPlugin = function () {\n    _createClass(RegionsPlugin, null, [{\n        key: 'create',\n\n        /**\n         * Regions plugin definition factory\n         *\n         * This function must be used to create a plugin definition which can be\n         * used by wavesurfer to correctly instantiate the plugin.\n         *\n         * @param {RegionsPluginParams} params parameters use to initialise the plugin\n         * @return {PluginDefinition} an object representing the plugin\n         */\n        value: function create(params) {\n            return {\n                name: 'regions',\n                deferInit: params && params.deferInit ? params.deferInit : false,\n                params: params,\n                staticProps: {\n                    initRegions: function initRegions() {\n                        console.warn('Deprecated initRegions! Use wavesurfer.initPlugins(\"regions\") instead!');\n                        this.initPlugin('regions');\n                    },\n                    addRegion: function addRegion(options) {\n                        if (!this.initialisedPluginList.regions) {\n                            this.initPlugin('regions');\n                        }\n                        return this.regions.add(options);\n                    },\n                    clearRegions: function clearRegions() {\n                        this.regions && this.regions.clear();\n                    },\n                    enableDragSelection: function enableDragSelection(options) {\n                        if (!this.initialisedPluginList.regions) {\n                            this.initPlugin('regions');\n                        }\n                        this.regions.enableDragSelection(options);\n                    },\n                    disableDragSelection: function disableDragSelection() {\n                        this.regions.disableDragSelection();\n                    }\n                },\n                instance: RegionsPlugin\n            };\n        }\n    }]);\n\n    function RegionsPlugin(params, ws) {\n        var _this5 = this;\n\n        _classCallCheck(this, RegionsPlugin);\n\n        this.params = params;\n        this.wavesurfer = ws;\n        this.util = ws.util;\n\n        // turn the plugin instance into an observer\n        var observerPrototypeKeys = Object.getOwnPropertyNames(this.util.Observer.prototype);\n        observerPrototypeKeys.forEach(function (key) {\n            Region.prototype[key] = _this5.util.Observer.prototype[key];\n        });\n        this.wavesurfer.Region = Region;\n\n        // Id-based hash of regions.\n        this.list = {};\n        this._onReady = function () {\n            _this5.wrapper = _this5.wavesurfer.drawer.wrapper;\n            if (_this5.params.regions) {\n                _this5.params.regions.forEach(function (region) {\n                    _this5.add(region);\n                });\n            }\n            if (_this5.params.dragSelection) {\n                _this5.enableDragSelection(_this5.params);\n            }\n        };\n    }\n\n    _createClass(RegionsPlugin, [{\n        key: 'init',\n        value: function init() {\n            // Check if ws is ready\n            if (this.wavesurfer.isReady) {\n                this._onReady();\n            }\n            this.wavesurfer.on('ready', this._onReady);\n        }\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this.wavesurfer.un('ready', this._onReady);\n            this.disableDragSelection();\n            this.clear();\n        }\n        /* Add a region. */\n\n    }, {\n        key: 'add',\n        value: function add(params) {\n            var _this6 = this;\n\n            var region = new this.wavesurfer.Region(params, this.wavesurfer);\n\n            this.list[region.id] = region;\n\n            region.on('remove', function () {\n                delete _this6.list[region.id];\n            });\n\n            return region;\n        }\n\n        /* Remove all regions. */\n\n    }, {\n        key: 'clear',\n        value: function clear() {\n            var _this7 = this;\n\n            Object.keys(this.list).forEach(function (id) {\n                _this7.list[id].remove();\n            });\n        }\n    }, {\n        key: 'enableDragSelection',\n        value: function enableDragSelection(params) {\n            var _this8 = this;\n\n            var slop = params.slop || 2;\n            var container = this.wavesurfer.drawer.container;\n            var scroll = params.scroll !== false && this.wavesurfer.params.scrollParent;\n            var scrollSpeed = params.scrollSpeed || 1;\n            var scrollThreshold = params.scrollThreshold || 10;\n            var drag = void 0;\n            var duration = this.wavesurfer.getDuration();\n            var maxScroll = void 0;\n            var start = void 0;\n            var region = void 0;\n            var touchId = void 0;\n            var pxMove = 0;\n            var scrollDirection = void 0;\n            var wrapperRect = void 0;\n\n            // Scroll when the user is dragging within the threshold\n            var edgeScroll = function edgeScroll(e) {\n                if (!region || !scrollDirection) {\n                    return;\n                }\n\n                // Update scroll position\n                var scrollLeft = _this8.wrapper.scrollLeft + scrollSpeed * scrollDirection;\n                _this8.wrapper.scrollLeft = scrollLeft = Math.min(maxScroll, Math.max(0, scrollLeft));\n\n                // Update range\n                var end = _this8.wavesurfer.drawer.handleEvent(e);\n                region.update({\n                    start: Math.min(end * duration, start * duration),\n                    end: Math.max(end * duration, start * duration)\n                });\n\n                // Check that there is more to scroll and repeat\n                if (scrollLeft < maxScroll && scrollLeft > 0) {\n                    window.requestAnimationFrame(function () {\n                        edgeScroll(e);\n                    });\n                }\n            };\n\n            var eventDown = function eventDown(e) {\n                if (e.touches && e.touches.length > 1) {\n                    return;\n                }\n                duration = _this8.wavesurfer.getDuration();\n                touchId = e.targetTouches ? e.targetTouches[0].identifier : null;\n\n                // Store for scroll calculations\n                maxScroll = _this8.wrapper.scrollWidth - _this8.wrapper.clientWidth;\n                wrapperRect = _this8.wrapper.getBoundingClientRect();\n\n                drag = true;\n                start = _this8.wavesurfer.drawer.handleEvent(e, true);\n                region = null;\n                scrollDirection = null;\n            };\n            this.wrapper.addEventListener('mousedown', eventDown);\n            this.wrapper.addEventListener('touchstart', eventDown);\n            this.on('disable-drag-selection', function () {\n                _this8.wrapper.removeEventListener('touchstart', eventDown);\n                _this8.wrapper.removeEventListener('mousedown', eventDown);\n            });\n\n            var eventUp = function eventUp(e) {\n                if (e.touches && e.touches.length > 1) {\n                    return;\n                }\n\n                drag = false;\n                pxMove = 0;\n                scrollDirection = null;\n\n                if (region) {\n                    _this8.util.preventClick();\n                    region.fireEvent('update-end', e);\n                    _this8.wavesurfer.fireEvent('region-update-end', region, e);\n                }\n\n                region = null;\n            };\n            this.wrapper.addEventListener('mouseup', eventUp);\n            this.wrapper.addEventListener('touchend', eventUp);\n\n            document.body.addEventListener('mouseup', eventUp);\n            document.body.addEventListener('touchend', eventUp);\n            this.on('disable-drag-selection', function () {\n                document.body.removeEventListener('mouseup', eventUp);\n                document.body.removeEventListener('touchend', eventUp);\n                _this8.wrapper.removeEventListener('touchend', eventUp);\n                _this8.wrapper.removeEventListener('mouseup', eventUp);\n            });\n\n            var eventMove = function eventMove(e) {\n                if (!drag) {\n                    return;\n                }\n                if (++pxMove <= slop) {\n                    return;\n                }\n\n                if (e.touches && e.touches.length > 1) {\n                    return;\n                }\n                if (e.targetTouches && e.targetTouches[0].identifier != touchId) {\n                    return;\n                }\n\n                if (!region) {\n                    region = _this8.add(params || {});\n                }\n\n                var end = _this8.wavesurfer.drawer.handleEvent(e);\n                region.update({\n                    start: Math.min(end * duration, start * duration),\n                    end: Math.max(end * duration, start * duration)\n                });\n\n                // If scrolling is enabled\n                if (scroll && container.clientWidth < _this8.wrapper.scrollWidth) {\n                    // Check threshold based on mouse\n                    var x = e.clientX - wrapperRect.left;\n                    if (x <= scrollThreshold) {\n                        scrollDirection = -1;\n                    } else if (x >= wrapperRect.right - scrollThreshold) {\n                        scrollDirection = 1;\n                    } else {\n                        scrollDirection = null;\n                    }\n                    scrollDirection && edgeScroll(e);\n                }\n            };\n            this.wrapper.addEventListener('mousemove', eventMove);\n            this.wrapper.addEventListener('touchmove', eventMove);\n            this.on('disable-drag-selection', function () {\n                _this8.wrapper.removeEventListener('touchmove', eventMove);\n                _this8.wrapper.removeEventListener('mousemove', eventMove);\n            });\n        }\n    }, {\n        key: 'disableDragSelection',\n        value: function disableDragSelection() {\n            this.fireEvent('disable-drag-selection');\n        }\n\n        /* Get current region\n         *  The smallest region that contains the current time.\n         *  If several such regions exist, we take the first.\n         *  Return null if none exist. */\n\n    }, {\n        key: 'getCurrentRegion',\n        value: function getCurrentRegion() {\n            var _this9 = this;\n\n            var time = this.wavesurfer.getCurrentTime();\n            var min = null;\n            Object.keys(this.list).forEach(function (id) {\n                var cur = _this9.list[id];\n                if (cur.start <= time && cur.end >= time) {\n                    if (!min || cur.end - cur.start < min.end - min.start) {\n                        min = cur;\n                    }\n                }\n            });\n\n            return min;\n        }\n    }]);\n\n    return RegionsPlugin;\n}();\n\nexports.default = RegionsPlugin;\nmodule.exports = exports['default'];\n\n/***/ })\n\n/******/ });\n});\n\n\n// WEBPACK FOOTER //\n// wavesurfer.regions.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"localhost:8080/dist/plugin/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 13d1c6398860074631e7","/**\n * (Single) Region plugin class\n *\n * Must be turned into an observer before instantiating. This is done in\n * RegionsPlugin (main plugin class)\n *\n * @extends {Observer}\n */\nclass Region {\n    constructor(params, ws) {\n        this.wavesurfer = ws;\n        this.wrapper = ws.drawer.wrapper;\n        this.util = ws.util;\n        this.style = this.util.style;\n\n        this.id = params.id == null ? ws.util.getId() : params.id;\n        this.start = Number(params.start) || 0;\n        this.end =\n            params.end == null\n                ? // small marker-like region\n                  this.start +\n                  4 / this.wrapper.scrollWidth * this.wavesurfer.getDuration()\n                : Number(params.end);\n        this.resize =\n            params.resize === undefined ? true : Boolean(params.resize);\n        this.drag = params.drag === undefined ? true : Boolean(params.drag);\n        this.loop = Boolean(params.loop);\n        this.color = params.color || 'rgba(0, 0, 0, 0.1)';\n        this.data = params.data || {};\n        this.attributes = params.attributes || {};\n\n        this.maxLength = params.maxLength;\n        this.minLength = params.minLength;\n        this._onRedraw = () => this.updateRender();\n\n        this.scroll = params.scroll !== false && ws.params.scrollParent;\n        this.scrollSpeed = params.scrollSpeed || 1;\n        this.scrollThreshold = params.scrollThreshold || 10;\n\n        this.bindInOut();\n        this.render();\n        this.wavesurfer.on('zoom', this._onRedraw);\n        this.wavesurfer.on('redraw', this._onRedraw);\n        this.wavesurfer.fireEvent('region-created', this);\n    }\n\n    /* Update region params. */\n    update(params) {\n        if (null != params.start) {\n            this.start = Number(params.start);\n        }\n        if (null != params.end) {\n            this.end = Number(params.end);\n        }\n        if (null != params.loop) {\n            this.loop = Boolean(params.loop);\n        }\n        if (null != params.color) {\n            this.color = params.color;\n        }\n        if (null != params.data) {\n            this.data = params.data;\n        }\n        if (null != params.resize) {\n            this.resize = Boolean(params.resize);\n        }\n        if (null != params.drag) {\n            this.drag = Boolean(params.drag);\n        }\n        if (null != params.maxLength) {\n            this.maxLength = Number(params.maxLength);\n        }\n        if (null != params.minLength) {\n            this.minLength = Number(params.minLength);\n        }\n        if (null != params.attributes) {\n            this.attributes = params.attributes;\n        }\n\n        this.updateRender();\n        this.fireEvent('update');\n        this.wavesurfer.fireEvent('region-updated', this);\n    }\n\n    /* Remove a single region. */\n    remove() {\n        if (this.element) {\n            this.wrapper.removeChild(this.element);\n            this.element = null;\n            this.fireEvent('remove');\n            this.wavesurfer.un('zoom', this._onRedraw);\n            this.wavesurfer.un('redraw', this._onRedraw);\n            this.wavesurfer.fireEvent('region-removed', this);\n        }\n    }\n\n    /* Play the audio region. */\n    play() {\n        this.wavesurfer.play(this.start, this.end);\n        this.fireEvent('play');\n        this.wavesurfer.fireEvent('region-play', this);\n    }\n\n    /* Play the region in loop. */\n    playLoop() {\n        this.play();\n        this.once('out', () => this.playLoop());\n    }\n\n    /* Render a region as a DOM element. */\n    render() {\n        const regionEl = document.createElement('region');\n        regionEl.className = 'wavesurfer-region';\n        regionEl.title = this.formatTime(this.start, this.end);\n        regionEl.setAttribute('data-id', this.id);\n\n        for (const attrname in this.attributes) {\n            regionEl.setAttribute(\n                'data-region-' + attrname,\n                this.attributes[attrname]\n            );\n        }\n\n        const width = this.wrapper.scrollWidth;\n        this.style(regionEl, {\n            position: 'absolute',\n            zIndex: 2,\n            height: '100%',\n            top: '0px'\n        });\n\n        /* Resize handles */\n        if (this.resize) {\n            const handleLeft = regionEl.appendChild(\n                document.createElement('handle')\n            );\n            const handleRight = regionEl.appendChild(\n                document.createElement('handle')\n            );\n            handleLeft.className = 'wavesurfer-handle wavesurfer-handle-start';\n            handleRight.className = 'wavesurfer-handle wavesurfer-handle-end';\n            const css = {\n                cursor: 'col-resize',\n                position: 'absolute',\n                left: '0px',\n                top: '0px',\n                width: '1%',\n                maxWidth: '4px',\n                height: '100%'\n            };\n            this.style(handleLeft, css);\n            this.style(handleRight, css);\n            this.style(handleRight, {\n                left: '100%'\n            });\n        }\n\n        this.element = this.wrapper.appendChild(regionEl);\n        this.updateRender();\n        this.bindEvents(regionEl);\n    }\n\n    formatTime(start, end) {\n        return (start == end ? [start] : [start, end])\n            .map(time =>\n                [\n                    Math.floor((time % 3600) / 60), // minutes\n                    ('00' + Math.floor(time % 60)).slice(-2) // seconds\n                ].join(':')\n            )\n            .join('-');\n    }\n\n    getWidth() {\n        return this.wavesurfer.drawer.width / this.wavesurfer.params.pixelRatio;\n    }\n\n    /* Update element's position, width, color. */\n    updateRender() {\n        const dur = this.wavesurfer.getDuration();\n        const width = this.getWidth();\n\n        if (this.start < 0) {\n            this.start = 0;\n            this.end = this.end - this.start;\n        }\n        if (this.end > dur) {\n            this.end = dur;\n            this.start = dur - (this.end - this.start);\n        }\n\n        if (this.minLength != null) {\n            this.end = Math.max(this.start + this.minLength, this.end);\n        }\n\n        if (this.maxLength != null) {\n            this.end = Math.min(this.start + this.maxLength, this.end);\n        }\n\n        if (this.element != null) {\n            // Calculate the left and width values of the region such that\n            // no gaps appear between regions.\n            const left = Math.round(this.start / dur * width);\n            const regionWidth = Math.round(this.end / dur * width) - left;\n\n            this.style(this.element, {\n                left: left + 'px',\n                width: regionWidth + 'px',\n                backgroundColor: this.color,\n                cursor: this.drag ? 'move' : 'default'\n            });\n\n            for (const attrname in this.attributes) {\n                this.element.setAttribute(\n                    'data-region-' + attrname,\n                    this.attributes[attrname]\n                );\n            }\n\n            this.element.title = this.formatTime(this.start, this.end);\n        }\n    }\n\n    /* Bind audio events. */\n    bindInOut() {\n        this.firedIn = false;\n        this.firedOut = false;\n\n        const onProcess = time => {\n            if (\n                !this.firedOut &&\n                this.firedIn &&\n                (this.start >= Math.round(time * 100) / 100 ||\n                    this.end <= Math.round(time * 100) / 100)\n            ) {\n                this.firedOut = true;\n                this.firedIn = false;\n                this.fireEvent('out');\n                this.wavesurfer.fireEvent('region-out', this);\n            }\n            if (!this.firedIn && this.start <= time && this.end > time) {\n                this.firedIn = true;\n                this.firedOut = false;\n                this.fireEvent('in');\n                this.wavesurfer.fireEvent('region-in', this);\n            }\n        };\n\n        this.wavesurfer.backend.on('audioprocess', onProcess);\n\n        this.on('remove', () => {\n            this.wavesurfer.backend.un('audioprocess', onProcess);\n        });\n\n        /* Loop playback. */\n        this.on('out', () => {\n            if (this.loop) {\n                this.wavesurfer.play(this.start);\n            }\n        });\n    }\n\n    /* Bind DOM events. */\n    bindEvents() {\n        this.element.addEventListener('mouseenter', e => {\n            this.fireEvent('mouseenter', e);\n            this.wavesurfer.fireEvent('region-mouseenter', this, e);\n        });\n\n        this.element.addEventListener('mouseleave', e => {\n            this.fireEvent('mouseleave', e);\n            this.wavesurfer.fireEvent('region-mouseleave', this, e);\n        });\n\n        this.element.addEventListener('click', e => {\n            e.preventDefault();\n            this.fireEvent('click', e);\n            this.wavesurfer.fireEvent('region-click', this, e);\n        });\n\n        this.element.addEventListener('dblclick', e => {\n            e.stopPropagation();\n            e.preventDefault();\n            this.fireEvent('dblclick', e);\n            this.wavesurfer.fireEvent('region-dblclick', this, e);\n        });\n\n        /* Drag or resize on mousemove. */\n        (this.drag || this.resize) &&\n            (() => {\n                const container = this.wavesurfer.drawer.container;\n                const duration = this.wavesurfer.getDuration();\n                const scrollSpeed = this.scrollSpeed;\n                const scrollThreshold = this.scrollThreshold;\n                let startTime;\n                let touchId;\n                let drag;\n                let maxScroll;\n                let resize;\n                let updated = false;\n                let scrollDirection;\n                let wrapperRect;\n\n                // Scroll when the user is dragging within the threshold\n                const edgeScroll = e => {\n                    if (!scrollDirection || (!drag && !resize)) {\n                        return;\n                    }\n\n                    // Update scroll position\n                    let scrollLeft =\n                        this.wrapper.scrollLeft + scrollSpeed * scrollDirection;\n                    this.wrapper.scrollLeft = scrollLeft = Math.min(\n                        maxScroll,\n                        Math.max(0, scrollLeft)\n                    );\n\n                    // Update time\n                    const time =\n                        this.wavesurfer.drawer.handleEvent(e) * duration;\n                    const delta = time - startTime;\n                    startTime = time;\n\n                    // Continue dragging or resizing\n                    drag ? this.onDrag(delta) : this.onResize(delta, resize);\n\n                    // Repeat\n                    window.requestAnimationFrame(() => {\n                        edgeScroll(e);\n                    });\n                };\n\n                const onDown = e => {\n                    if (e.touches && e.touches.length > 1) {\n                        return;\n                    }\n                    touchId = e.targetTouches\n                        ? e.targetTouches[0].identifier\n                        : null;\n\n                    e.stopPropagation();\n                    startTime =\n                        this.wavesurfer.drawer.handleEvent(e, true) * duration;\n\n                    // Store for scroll calculations\n                    maxScroll =\n                        this.wrapper.scrollWidth - this.wrapper.clientWidth;\n                    wrapperRect = this.wrapper.getBoundingClientRect();\n\n                    if (e.target.tagName.toLowerCase() == 'handle') {\n                        if (\n                            e.target.classList.contains(\n                                'wavesurfer-handle-start'\n                            )\n                        ) {\n                            resize = 'start';\n                        } else {\n                            resize = 'end';\n                        }\n                    } else {\n                        drag = true;\n                        resize = false;\n                    }\n                };\n                const onUp = e => {\n                    if (e.touches && e.touches.length > 1) {\n                        return;\n                    }\n\n                    if (drag || resize) {\n                        drag = false;\n                        scrollDirection = null;\n                        resize = false;\n                    }\n\n                    if (updated) {\n                        updated = false;\n                        this.util.preventClick();\n                        this.fireEvent('update-end', e);\n                        this.wavesurfer.fireEvent('region-update-end', this, e);\n                    }\n                };\n                const onMove = e => {\n                    if (e.touches && e.touches.length > 1) {\n                        return;\n                    }\n                    if (\n                        e.targetTouches &&\n                        e.targetTouches[0].identifier != touchId\n                    ) {\n                        return;\n                    }\n\n                    if (drag || resize) {\n                        const oldTime = startTime;\n                        const time =\n                            this.wavesurfer.drawer.handleEvent(e) * duration;\n                        const delta = time - startTime;\n                        startTime = time;\n\n                        // Drag\n                        if (this.drag && drag) {\n                            updated = updated || !!delta;\n                            this.onDrag(delta);\n                        }\n\n                        // Resize\n                        if (this.resize && resize) {\n                            updated = updated || !!delta;\n                            this.onResize(delta, resize);\n                        }\n\n                        if (\n                            this.scroll &&\n                            container.clientWidth < this.wrapper.scrollWidth\n                        ) {\n                            if (drag) {\n                                // The threshold is not between the mouse and the container edge\n                                // but is between the region and the container edge\n                                const regionRect = this.element.getBoundingClientRect();\n                                let x = regionRect.left - wrapperRect.left;\n\n                                // Check direction\n                                if (time < oldTime && x >= 0) {\n                                    scrollDirection = -1;\n                                } else if (\n                                    time > oldTime &&\n                                    x + regionRect.width <= wrapperRect.right\n                                ) {\n                                    scrollDirection = 1;\n                                }\n\n                                // Check that we are still beyond the threshold\n                                if (\n                                    (scrollDirection === -1 &&\n                                        x > scrollThreshold) ||\n                                    (scrollDirection === 1 &&\n                                        x + regionRect.width <\n                                            wrapperRect.right - scrollThreshold)\n                                ) {\n                                    scrollDirection = null;\n                                }\n                            } else {\n                                // Mouse based threshold\n                                let x = e.clientX - wrapperRect.left;\n\n                                // Check direction\n                                if (x <= scrollThreshold) {\n                                    scrollDirection = -1;\n                                } else if (\n                                    x >=\n                                    wrapperRect.right - scrollThreshold\n                                ) {\n                                    scrollDirection = 1;\n                                } else {\n                                    scrollDirection = null;\n                                }\n                            }\n\n                            scrollDirection && edgeScroll(e);\n                        }\n                    }\n                };\n\n                this.element.addEventListener('mousedown', onDown);\n                this.element.addEventListener('touchstart', onDown);\n\n                this.wrapper.addEventListener('mousemove', onMove);\n                this.wrapper.addEventListener('touchmove', onMove);\n\n                document.body.addEventListener('mouseup', onUp);\n                document.body.addEventListener('touchend', onUp);\n\n                this.on('remove', () => {\n                    document.body.removeEventListener('mouseup', onUp);\n                    document.body.removeEventListener('touchend', onUp);\n                    this.wrapper.removeEventListener('mousemove', onMove);\n                    this.wrapper.removeEventListener('touchmove', onMove);\n                });\n\n                this.wavesurfer.on('destroy', () => {\n                    document.body.removeEventListener('mouseup', onUp);\n                    document.body.removeEventListener('touchend', onUp);\n                });\n            })();\n    }\n\n    onDrag(delta) {\n        const maxEnd = this.wavesurfer.getDuration();\n        if (this.end + delta > maxEnd || this.start + delta < 0) {\n            return;\n        }\n\n        this.update({\n            start: this.start + delta,\n            end: this.end + delta\n        });\n    }\n\n    onResize(delta, direction) {\n        if (direction == 'start') {\n            this.update({\n                start: Math.min(this.start + delta, this.end),\n                end: Math.max(this.start + delta, this.end)\n            });\n        } else {\n            this.update({\n                start: Math.min(this.end + delta, this.start),\n                end: Math.max(this.end + delta, this.start)\n            });\n        }\n    }\n}\n\n/**\n * @typedef {Object} RegionsPluginParams\n * @property {?boolean} dragSelection Enable creating regions by dragging wih\n * the mouse\n * @property {?RegionParams[]} regions Regions that should be added upon\n * initialisation\n * @property {number} slop=2 The sensitivity of the mouse dragging\n * @property {?boolean} deferInit Set to true to manually call\n * `initPlugin('regions')`\n */\n\n/**\n * @typedef {Object} RegionParams\n * @desc The parameters used to describe a region.\n * @example wavesurfer.addRegion(regionParams);\n * @property {string} id=â†’random The id of the region\n * @property {number} start=0 The start position of the region (in seconds).\n * @property {number} end=0 The end position of the region (in seconds).\n * @property {?boolean} loop Whether to loop the region when played back.\n * @property {boolean} drag=true Allow/dissallow dragging the region.\n * @property {boolean} resize=true Allow/dissallow resizing the region.\n * @property {string} [color='rgba(0, 0, 0, 0.1)'] HTML color code.\n */\n\n/**\n * Regions are visual overlays on waveform that can be used to play and loop\n * portions of audio. Regions can be dragged and resized.\n *\n * Visual customization is possible via CSS (using the selectors\n * `.wavesurfer-region` and `.wavesurfer-handle`).\n *\n * @implements {PluginClass}\n * @extends {Observer}\n *\n * @example\n * // es6\n * import RegionsPlugin from 'wavesurfer.regions.js';\n *\n * // commonjs\n * var RegionsPlugin = require('wavesurfer.regions.js');\n *\n * // if you are using <script> tags\n * var RegionsPlugin = window.WaveSurfer.regions;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     RegionsPlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\nexport default class RegionsPlugin {\n    /**\n     * Regions plugin definition factory\n     *\n     * This function must be used to create a plugin definition which can be\n     * used by wavesurfer to correctly instantiate the plugin.\n     *\n     * @param {RegionsPluginParams} params parameters use to initialise the plugin\n     * @return {PluginDefinition} an object representing the plugin\n     */\n    static create(params) {\n        return {\n            name: 'regions',\n            deferInit: params && params.deferInit ? params.deferInit : false,\n            params: params,\n            staticProps: {\n                initRegions() {\n                    console.warn(\n                        'Deprecated initRegions! Use wavesurfer.initPlugins(\"regions\") instead!'\n                    );\n                    this.initPlugin('regions');\n                },\n\n                addRegion(options) {\n                    if (!this.initialisedPluginList.regions) {\n                        this.initPlugin('regions');\n                    }\n                    return this.regions.add(options);\n                },\n\n                clearRegions() {\n                    this.regions && this.regions.clear();\n                },\n\n                enableDragSelection(options) {\n                    if (!this.initialisedPluginList.regions) {\n                        this.initPlugin('regions');\n                    }\n                    this.regions.enableDragSelection(options);\n                },\n\n                disableDragSelection() {\n                    this.regions.disableDragSelection();\n                }\n            },\n            instance: RegionsPlugin\n        };\n    }\n\n    constructor(params, ws) {\n        this.params = params;\n        this.wavesurfer = ws;\n        this.util = ws.util;\n\n        // turn the plugin instance into an observer\n        const observerPrototypeKeys = Object.getOwnPropertyNames(\n            this.util.Observer.prototype\n        );\n        observerPrototypeKeys.forEach(key => {\n            Region.prototype[key] = this.util.Observer.prototype[key];\n        });\n        this.wavesurfer.Region = Region;\n\n        // Id-based hash of regions.\n        this.list = {};\n        this._onReady = () => {\n            this.wrapper = this.wavesurfer.drawer.wrapper;\n            if (this.params.regions) {\n                this.params.regions.forEach(region => {\n                    this.add(region);\n                });\n            }\n            if (this.params.dragSelection) {\n                this.enableDragSelection(this.params);\n            }\n        };\n    }\n\n    init() {\n        // Check if ws is ready\n        if (this.wavesurfer.isReady) {\n            this._onReady();\n        }\n        this.wavesurfer.on('ready', this._onReady);\n    }\n\n    destroy() {\n        this.wavesurfer.un('ready', this._onReady);\n        this.disableDragSelection();\n        this.clear();\n    }\n    /* Add a region. */\n    add(params) {\n        const region = new this.wavesurfer.Region(params, this.wavesurfer);\n\n        this.list[region.id] = region;\n\n        region.on('remove', () => {\n            delete this.list[region.id];\n        });\n\n        return region;\n    }\n\n    /* Remove all regions. */\n    clear() {\n        Object.keys(this.list).forEach(id => {\n            this.list[id].remove();\n        });\n    }\n\n    enableDragSelection(params) {\n        const slop = params.slop || 2;\n        const container = this.wavesurfer.drawer.container;\n        const scroll =\n            params.scroll !== false && this.wavesurfer.params.scrollParent;\n        const scrollSpeed = params.scrollSpeed || 1;\n        const scrollThreshold = params.scrollThreshold || 10;\n        let drag;\n        let duration = this.wavesurfer.getDuration();\n        let maxScroll;\n        let start;\n        let region;\n        let touchId;\n        let pxMove = 0;\n        let scrollDirection;\n        let wrapperRect;\n\n        // Scroll when the user is dragging within the threshold\n        const edgeScroll = e => {\n            if (!region || !scrollDirection) {\n                return;\n            }\n\n            // Update scroll position\n            let scrollLeft =\n                this.wrapper.scrollLeft + scrollSpeed * scrollDirection;\n            this.wrapper.scrollLeft = scrollLeft = Math.min(\n                maxScroll,\n                Math.max(0, scrollLeft)\n            );\n\n            // Update range\n            const end = this.wavesurfer.drawer.handleEvent(e);\n            region.update({\n                start: Math.min(end * duration, start * duration),\n                end: Math.max(end * duration, start * duration)\n            });\n\n            // Check that there is more to scroll and repeat\n            if (scrollLeft < maxScroll && scrollLeft > 0) {\n                window.requestAnimationFrame(() => {\n                    edgeScroll(e);\n                });\n            }\n        };\n\n        const eventDown = e => {\n            if (e.touches && e.touches.length > 1) {\n                return;\n            }\n            duration = this.wavesurfer.getDuration();\n            touchId = e.targetTouches ? e.targetTouches[0].identifier : null;\n\n            // Store for scroll calculations\n            maxScroll = this.wrapper.scrollWidth - this.wrapper.clientWidth;\n            wrapperRect = this.wrapper.getBoundingClientRect();\n\n            drag = true;\n            start = this.wavesurfer.drawer.handleEvent(e, true);\n            region = null;\n            scrollDirection = null;\n        };\n        this.wrapper.addEventListener('mousedown', eventDown);\n        this.wrapper.addEventListener('touchstart', eventDown);\n        this.on('disable-drag-selection', () => {\n            this.wrapper.removeEventListener('touchstart', eventDown);\n            this.wrapper.removeEventListener('mousedown', eventDown);\n        });\n\n        const eventUp = e => {\n            if (e.touches && e.touches.length > 1) {\n                return;\n            }\n\n            drag = false;\n            pxMove = 0;\n            scrollDirection = null;\n\n            if (region) {\n                this.util.preventClick();\n                region.fireEvent('update-end', e);\n                this.wavesurfer.fireEvent('region-update-end', region, e);\n            }\n\n            region = null;\n        };\n        this.wrapper.addEventListener('mouseup', eventUp);\n        this.wrapper.addEventListener('touchend', eventUp);\n\n        document.body.addEventListener('mouseup', eventUp);\n        document.body.addEventListener('touchend', eventUp);\n        this.on('disable-drag-selection', () => {\n            document.body.removeEventListener('mouseup', eventUp);\n            document.body.removeEventListener('touchend', eventUp);\n            this.wrapper.removeEventListener('touchend', eventUp);\n            this.wrapper.removeEventListener('mouseup', eventUp);\n        });\n\n        const eventMove = e => {\n            if (!drag) {\n                return;\n            }\n            if (++pxMove <= slop) {\n                return;\n            }\n\n            if (e.touches && e.touches.length > 1) {\n                return;\n            }\n            if (e.targetTouches && e.targetTouches[0].identifier != touchId) {\n                return;\n            }\n\n            if (!region) {\n                region = this.add(params || {});\n            }\n\n            const end = this.wavesurfer.drawer.handleEvent(e);\n            region.update({\n                start: Math.min(end * duration, start * duration),\n                end: Math.max(end * duration, start * duration)\n            });\n\n            // If scrolling is enabled\n            if (scroll && container.clientWidth < this.wrapper.scrollWidth) {\n                // Check threshold based on mouse\n                const x = e.clientX - wrapperRect.left;\n                if (x <= scrollThreshold) {\n                    scrollDirection = -1;\n                } else if (x >= wrapperRect.right - scrollThreshold) {\n                    scrollDirection = 1;\n                } else {\n                    scrollDirection = null;\n                }\n                scrollDirection && edgeScroll(e);\n            }\n        };\n        this.wrapper.addEventListener('mousemove', eventMove);\n        this.wrapper.addEventListener('touchmove', eventMove);\n        this.on('disable-drag-selection', () => {\n            this.wrapper.removeEventListener('touchmove', eventMove);\n            this.wrapper.removeEventListener('mousemove', eventMove);\n        });\n    }\n\n    disableDragSelection() {\n        this.fireEvent('disable-drag-selection');\n    }\n\n    /* Get current region\n     *  The smallest region that contains the current time.\n     *  If several such regions exist, we take the first.\n     *  Return null if none exist. */\n    getCurrentRegion() {\n        const time = this.wavesurfer.getCurrentTime();\n        let min = null;\n        Object.keys(this.list).forEach(id => {\n            const cur = this.list[id];\n            if (cur.start <= time && cur.end >= time) {\n                if (!min || cur.end - cur.start < min.end - min.start) {\n                    min = cur;\n                }\n            }\n        });\n\n        return min;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugin/regions.js"],"sourceRoot":""}