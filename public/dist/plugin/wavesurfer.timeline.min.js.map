{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///wavesurfer.timeline.min.js","webpack:///webpack/bootstrap 13d1c6398860074631e7","webpack:///./src/plugin/timeline.js"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","value","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","TimelinePlugin","params","ws","_this","_initialiseProps","container","document","querySelector","Error","wavesurfer","util","extend","height","notchPercentHeight","labelPadding","primaryColor","secondaryColor","primaryFontColor","secondaryFontColor","fontFamily","fontSize","zoomDebounce","formatTimeCallback","seconds","minutes","parseInt","Math","round","timeInterval","pxPerSec","ceil","primaryLabelInterval","secondaryLabelInterval","canvases","wrapper","drawer","pixelRatio","maxCanvasWidth","maxCanvasElementWidth","_onZoom","debounce","render","deferInit","on","_onReady","isReady","unAll","un","_onRedraw","removeEventListener","_onScroll","parentNode","_onWrapperClick","removeChild","wsParams","innerHTML","appendChild","createElement","style","display","position","userSelect","webkitUserSelect","fillParent","scrollParent","width","overflowX","overflowY","addEventListener","createWrapper","updateCanvases","updateCanvasesPositioning","renderCanvases","_this2","totalWidth","scrollWidth","requiredCanvases","canvas","push","zIndex","pop","parentElement","_this3","canvasesLength","forEach","canvasWidth","left","_this4","duration","backend","getDuration","totalSeconds","getWidth","height1","height2","pixelsPerSecond","formatTime","intervalFnOrVal","option","curPixel","curSeconds","positioning","renderPositions","cb","pos","setFillStyles","setFonts","fillRect","fillText","fillStyle","getContext","font","x","y","_this5","leftOffset","intersection","x1","max","y1","x2","min","y2","text","textWidth","xOffset","context","measureText","_this6","scrollLeft","e","preventDefault","relX","offsetX","layerX","fireEvent","default"],"mappings":"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","file":"wavesurfer.timeline.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"timeline\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"timeline\"] = factory();\n\telse\n\t\troot[\"WaveSurfer\"] = root[\"WaveSurfer\"] || {}, root[\"WaveSurfer\"][\"timeline\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*!\n * wavesurfer.js 2.0.5 (Tue Mar 27 2018 22:41:46 GMT+0200 (SAST))\n * https://github.com/katspaugh/wavesurfer.js\n * @license BSD-3-Clause\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"timeline\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"timeline\"] = factory();\n\telse\n\t\troot[\"WaveSurfer\"] = root[\"WaveSurfer\"] || {}, root[\"WaveSurfer\"][\"timeline\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"localhost:8080/dist/plugin/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @typedef {Object} TimelinePluginParams\n * @desc Extends the `WavesurferParams` wavesurfer was initialised with\n * @property {!string|HTMLElement} container CSS selector or HTML element where\n * the timeline should be drawn. This is the only required parameter.\n * @property {number} notchPercentHeight=90 Height of notches in percent\n * @property {string} primaryColor='#000' The colour of the main notches\n * @property {string} secondaryColor='#c0c0c0' The colour of the secondary\n * notches\n * @property {string} primaryFontColor='#000' The colour of the labels next to\n * the main notches\n * @property {string} secondaryFontColor='#000' The colour of the labels next to\n * the secondary notches\n * @property {number} labelPadding=5 The padding between the label and the notch\n * @property {?number} zoomDebounce A debounce timeout to increase rendering\n * performance for large files\n * @property {string} fontFamily='Arial'\n * @property {number} fontSize=10 Font size of labels in pixels\n * @property {function} formatTimeCallback=→00:00\n * @property {?boolean} deferInit Set to true to manually call\n * `initPlugin('timeline')`\n */\n\n/**\n * Adds a timeline to the waveform.\n *\n * @implements {PluginClass}\n * @extends {Observer}\n * @example\n * // es6\n * import TimelinePlugin from 'wavesurfer.timeline.js';\n *\n * // commonjs\n * var TimelinePlugin = require('wavesurfer.timeline.js');\n *\n * // if you are using <script> tags\n * var TimelinePlugin = window.WaveSurfer.timeline;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     TimelinePlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\nvar TimelinePlugin = function () {\n    _createClass(TimelinePlugin, null, [{\n        key: 'create',\n\n        /**\n         * Timeline plugin definition factory\n         *\n         * This function must be used to create a plugin definition which can be\n         * used by wavesurfer to correctly instantiate the plugin.\n         *\n         * @param  {TimelinePluginParams} params parameters use to initialise the plugin\n         * @return {PluginDefinition} an object representing the plugin\n         */\n        value: function create(params) {\n            return {\n                name: 'timeline',\n                deferInit: params && params.deferInit ? params.deferInit : false,\n                params: params,\n                instance: TimelinePlugin\n            };\n        }\n\n        // event handlers\n        /** @private */\n\n        /** @private */\n\n        /** @private */\n\n        /** @private */\n\n    }]);\n\n    /**\n     * Creates an instance of TimelinePlugin.\n     *\n     * You probably want to use TimelinePlugin.create()\n     *\n     * @param {TimelinePluginParams} params Plugin parameters\n     * @param {object} ws Wavesurfer instance\n     */\n    function TimelinePlugin(params, ws) {\n        var _this = this;\n\n        _classCallCheck(this, TimelinePlugin);\n\n        _initialiseProps.call(this);\n\n        /** @private */\n        this.container = 'string' == typeof params.container ? document.querySelector(params.container) : params.container;\n\n        if (!this.container) {\n            throw new Error('No container for wavesurfer timeline');\n        }\n        /** @private */\n        this.wavesurfer = ws;\n        /** @private */\n        this.util = ws.util;\n        /** @private */\n        this.params = this.util.extend({}, {\n            height: 20,\n            notchPercentHeight: 90,\n            labelPadding: 5,\n            primaryColor: '#000',\n            secondaryColor: '#c0c0c0',\n            primaryFontColor: '#000',\n            secondaryFontColor: '#000',\n            fontFamily: 'Arial',\n            fontSize: 10,\n            zoomDebounce: false,\n            formatTimeCallback: function formatTimeCallback(seconds) {\n                if (seconds / 60 > 1) {\n                    // calculate minutes and seconds from seconds count\n                    var minutes = parseInt(seconds / 60, 10);\n                    seconds = parseInt(seconds % 60, 10);\n                    // fill up seconds with zeroes\n                    seconds = seconds < 10 ? '0' + seconds : seconds;\n                    return minutes + ':' + seconds;\n                }\n                return Math.round(seconds * 1000) / 1000;\n            },\n            timeInterval: function timeInterval(pxPerSec) {\n                if (pxPerSec >= 25) {\n                    return 1;\n                } else if (pxPerSec * 5 >= 25) {\n                    return 5;\n                } else if (pxPerSec * 15 >= 25) {\n                    return 15;\n                }\n                return Math.ceil(0.5 / pxPerSec) * 60;\n            },\n            primaryLabelInterval: function primaryLabelInterval(pxPerSec) {\n                if (pxPerSec >= 25) {\n                    return 10;\n                } else if (pxPerSec * 5 >= 25) {\n                    return 6;\n                } else if (pxPerSec * 15 >= 25) {\n                    return 4;\n                }\n                return 4;\n            },\n            secondaryLabelInterval: function secondaryLabelInterval(pxPerSec) {\n                if (pxPerSec >= 25) {\n                    return 5;\n                } else if (pxPerSec * 5 >= 25) {\n                    return 2;\n                } else if (pxPerSec * 15 >= 25) {\n                    return 2;\n                }\n                return 2;\n            }\n        }, params);\n\n        /** @private */\n        this.canvases = [];\n        /** @private */\n        this.wrapper = null;\n        /** @private */\n        this.drawer = null;\n        /** @private */\n        this.pixelRatio = null;\n        /** @private */\n        this.maxCanvasWidth = null;\n        /** @private */\n        this.maxCanvasElementWidth = null;\n        /**\n         * This event handler has to be in the constructor function because it\n         * relies on the debounce function which is only available after\n         * instantiation\n         *\n         * Use a debounced function if zoomDebounce is defined\n         *\n         * @private\n         */\n        this._onZoom = this.params.zoomDebounce ? this.wavesurfer.util.debounce(function () {\n            return _this.render();\n        }, this.params.zoomDebounce) : function () {\n            return _this.render();\n        };\n    }\n\n    /**\n     * Initialisation function used by the plugin API\n     */\n\n\n    _createClass(TimelinePlugin, [{\n        key: 'init',\n        value: function init() {\n            this.wavesurfer.on('ready', this._onReady);\n            // Check if ws is ready\n            if (this.wavesurfer.isReady) {\n                this._onReady();\n            }\n        }\n\n        /**\n         * Destroy function used by the plugin API\n         */\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this.unAll();\n            this.wavesurfer.un('redraw', this._onRedraw);\n            this.wavesurfer.un('zoom', this._onZoom);\n            this.wavesurfer.un('ready', this._onReady);\n            this.wavesurfer.drawer.wrapper.removeEventListener('scroll', this._onScroll);\n            if (this.wrapper && this.wrapper.parentNode) {\n                this.wrapper.removeEventListener('click', this._onWrapperClick);\n                this.wrapper.parentNode.removeChild(this.wrapper);\n                this.wrapper = null;\n            }\n        }\n\n        /**\n         * Create a timeline element to wrap the canvases drawn by this plugin\n         *\n         * @private\n         */\n\n    }, {\n        key: 'createWrapper',\n        value: function createWrapper() {\n            var wsParams = this.wavesurfer.params;\n            this.container.innerHTML = '';\n            this.wrapper = this.container.appendChild(document.createElement('timeline'));\n            this.util.style(this.wrapper, {\n                display: 'block',\n                position: 'relative',\n                userSelect: 'none',\n                webkitUserSelect: 'none',\n                height: this.params.height + 'px'\n            });\n\n            if (wsParams.fillParent || wsParams.scrollParent) {\n                this.util.style(this.wrapper, {\n                    width: '100%',\n                    overflowX: 'hidden',\n                    overflowY: 'hidden'\n                });\n            }\n\n            this.wrapper.addEventListener('click', this._onWrapperClick);\n        }\n\n        /**\n         * Render the timeline (also updates the already rendered timeline)\n         *\n         * @private\n         */\n\n    }, {\n        key: 'render',\n        value: function render() {\n            if (!this.wrapper) {\n                this.createWrapper();\n            }\n            this.updateCanvases();\n            this.updateCanvasesPositioning();\n            this.renderCanvases();\n        }\n\n        /**\n         * Make sure the correct of timeline canvas elements exist and are cached in\n         * this.canvases\n         *\n         * @private\n         */\n\n    }, {\n        key: 'updateCanvases',\n        value: function updateCanvases() {\n            var _this2 = this;\n\n            var addCanvas = function addCanvas() {\n                var canvas = _this2.wrapper.appendChild(document.createElement('canvas'));\n                _this2.canvases.push(canvas);\n                _this2.util.style(canvas, {\n                    position: 'absolute',\n                    zIndex: 4\n                });\n            };\n            var removeCanvas = function removeCanvas() {\n                var canvas = _this2.canvases.pop();\n                canvas.parentElement.removeChild(canvas);\n            };\n\n            var totalWidth = Math.round(this.drawer.wrapper.scrollWidth);\n            var requiredCanvases = Math.ceil(totalWidth / this.maxCanvasElementWidth);\n            while (this.canvases.length < requiredCanvases) {\n                addCanvas();\n            }\n\n            while (this.canvases.length > requiredCanvases) {\n                removeCanvas();\n            }\n        }\n\n        /**\n         * Update the dimensions and positioning style for all the timeline canvases\n         *\n         * @private\n         */\n\n    }, {\n        key: 'updateCanvasesPositioning',\n        value: function updateCanvasesPositioning() {\n            var _this3 = this;\n\n            // cache length for perf\n            var canvasesLength = this.canvases.length;\n            this.canvases.forEach(function (canvas, i) {\n                // canvas width is the max element width, or if it is the last the\n                // required width\n                var canvasWidth = i === canvasesLength - 1 ? _this3.drawer.wrapper.scrollWidth - _this3.maxCanvasElementWidth * (canvasesLength - 1) : _this3.maxCanvasElementWidth;\n                // set dimensions and style\n                canvas.width = canvasWidth * _this3.pixelRatio;\n                // on certain pixel ratios the canvas appears cut off at the bottom,\n                // therefore leave 1px extra\n                canvas.height = (_this3.params.height + 1) * _this3.pixelRatio;\n                _this3.util.style(canvas, {\n                    width: canvasWidth + 'px',\n                    height: _this3.params.height + 'px',\n                    left: i * _this3.maxCanvasElementWidth + 'px'\n                });\n            });\n        }\n\n        /**\n         * Render the timeline labels and notches\n         *\n         * @private\n         */\n\n    }, {\n        key: 'renderCanvases',\n        value: function renderCanvases() {\n            var _this4 = this;\n\n            var duration = this.wavesurfer.backend.getDuration();\n            if (duration <= 0) {\n                return;\n            }\n            var wsParams = this.wavesurfer.params;\n            var fontSize = this.params.fontSize * wsParams.pixelRatio;\n            var totalSeconds = parseInt(duration, 10) + 1;\n            var width = wsParams.fillParent && !wsParams.scrollParent ? this.drawer.getWidth() : this.drawer.wrapper.scrollWidth * wsParams.pixelRatio;\n            var height1 = this.params.height * this.pixelRatio;\n            var height2 = this.params.height * (this.params.notchPercentHeight / 100) * this.pixelRatio;\n            var pixelsPerSecond = width / duration;\n\n            var formatTime = this.params.formatTimeCallback;\n            // if parameter is function, call the function with\n            // pixelsPerSecond, otherwise simply take the value as-is\n            var intervalFnOrVal = function intervalFnOrVal(option) {\n                return typeof option === 'function' ? option(pixelsPerSecond) : option;\n            };\n            var timeInterval = intervalFnOrVal(this.params.timeInterval);\n            var primaryLabelInterval = intervalFnOrVal(this.params.primaryLabelInterval);\n            var secondaryLabelInterval = intervalFnOrVal(this.params.secondaryLabelInterval);\n\n            var curPixel = 0;\n            var curSeconds = 0;\n            var i = void 0;\n            // build an array of position data with index, second and pixel data,\n            // this is then used multiple times below\n            var positioning = [];\n            for (i = 0; i < totalSeconds / timeInterval; i++) {\n                positioning.push([i, curSeconds, curPixel]);\n                curSeconds += timeInterval;\n                curPixel += pixelsPerSecond * timeInterval;\n            }\n\n            // iterate over each position\n            var renderPositions = function renderPositions(cb) {\n                positioning.forEach(function (pos) {\n                    cb(pos[0], pos[1], pos[2]);\n                });\n            };\n\n            // render primary labels\n            this.setFillStyles(this.params.primaryColor);\n            this.setFonts(fontSize + 'px ' + this.params.fontFamily);\n            this.setFillStyles(this.params.primaryFontColor);\n            renderPositions(function (i, curSeconds, curPixel) {\n                if (i % primaryLabelInterval === 0) {\n                    _this4.fillRect(curPixel, 0, 1, height1);\n                    _this4.fillText(formatTime(curSeconds), curPixel + _this4.params.labelPadding * _this4.pixelRatio, height1);\n                }\n            });\n\n            // render secondary labels\n            this.setFillStyles(this.params.secondaryColor);\n            this.setFonts(fontSize + 'px ' + this.params.fontFamily);\n            this.setFillStyles(this.params.secondaryFontColor);\n            renderPositions(function (i, curSeconds, curPixel) {\n                if (i % secondaryLabelInterval === 0) {\n                    _this4.fillRect(curPixel, 0, 1, height1);\n                    _this4.fillText(formatTime(curSeconds), curPixel + _this4.params.labelPadding * _this4.pixelRatio, height1);\n                }\n            });\n\n            // render the actual notches (when no labels are used)\n            this.setFillStyles(this.params.secondaryColor);\n            renderPositions(function (i, curSeconds, curPixel) {\n                if (i % secondaryLabelInterval !== 0 && i % primaryLabelInterval !== 0) {\n                    _this4.fillRect(curPixel, 0, 1, height2);\n                }\n            });\n        }\n\n        /**\n         * Set the canvas fill style\n         *\n         * @param {DOMString|CanvasGradient|CanvasPattern} fillStyle\n         * @private\n         */\n\n    }, {\n        key: 'setFillStyles',\n        value: function setFillStyles(fillStyle) {\n            this.canvases.forEach(function (canvas) {\n                canvas.getContext('2d').fillStyle = fillStyle;\n            });\n        }\n\n        /**\n         * Set the canvas font\n         *\n         * @param {DOMString} font\n         * @private\n         */\n\n    }, {\n        key: 'setFonts',\n        value: function setFonts(font) {\n            this.canvases.forEach(function (canvas) {\n                canvas.getContext('2d').font = font;\n            });\n        }\n\n        /**\n         * Draw a rectangle on the canvases\n         *\n         * (it figures out the offset for each canvas)\n         *\n         * @param {number} x\n         * @param {number} y\n         * @param {number} width\n         * @param {number} height\n         * @private\n         */\n\n    }, {\n        key: 'fillRect',\n        value: function fillRect(x, y, width, height) {\n            var _this5 = this;\n\n            this.canvases.forEach(function (canvas, i) {\n                var leftOffset = i * _this5.maxCanvasWidth;\n\n                var intersection = {\n                    x1: Math.max(x, i * _this5.maxCanvasWidth),\n                    y1: y,\n                    x2: Math.min(x + width, i * _this5.maxCanvasWidth + canvas.width),\n                    y2: y + height\n                };\n\n                if (intersection.x1 < intersection.x2) {\n                    canvas.getContext('2d').fillRect(intersection.x1 - leftOffset, intersection.y1, intersection.x2 - intersection.x1, intersection.y2 - intersection.y1);\n                }\n            });\n        }\n\n        /**\n         * Fill a given text on the canvases\n         *\n         * @param {string} text\n         * @param {number} x\n         * @param {number} y\n         * @private\n         */\n\n    }, {\n        key: 'fillText',\n        value: function fillText(text, x, y) {\n            var textWidth = void 0;\n            var xOffset = 0;\n\n            this.canvases.forEach(function (canvas) {\n                var context = canvas.getContext('2d');\n                var canvasWidth = context.canvas.width;\n\n                if (xOffset > x + textWidth) {\n                    return;\n                }\n\n                if (xOffset + canvasWidth > x) {\n                    textWidth = context.measureText(text).width;\n                    context.fillText(text, x - xOffset, y);\n                }\n\n                xOffset += canvasWidth;\n            });\n        }\n    }]);\n\n    return TimelinePlugin;\n}();\n\nvar _initialiseProps = function _initialiseProps() {\n    var _this6 = this;\n\n    this._onScroll = function () {\n        if (_this6.wrapper && _this6.drawer.wrapper) {\n            _this6.wrapper.scrollLeft = _this6.drawer.wrapper.scrollLeft;\n        }\n    };\n\n    this._onRedraw = function () {\n        return _this6.render();\n    };\n\n    this._onReady = function () {\n        var ws = _this6.wavesurfer;\n        _this6.drawer = ws.drawer;\n        _this6.pixelRatio = ws.drawer.params.pixelRatio;\n        _this6.maxCanvasWidth = ws.drawer.maxCanvasWidth || ws.drawer.width;\n        _this6.maxCanvasElementWidth = ws.drawer.maxCanvasElementWidth || Math.round(_this6.maxCanvasWidth / _this6.pixelRatio);\n\n        ws.drawer.wrapper.addEventListener('scroll', _this6._onScroll);\n        ws.on('redraw', _this6._onRedraw);\n        ws.on('zoom', _this6._onZoom);\n        _this6.render();\n    };\n\n    this._onWrapperClick = function (e) {\n        e.preventDefault();\n        var relX = 'offsetX' in e ? e.offsetX : e.layerX;\n        _this6.fireEvent('click', relX / _this6.wrapper.scrollWidth || 0);\n    };\n};\n\nexports.default = TimelinePlugin;\nmodule.exports = exports['default'];\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// wavesurfer.timeline.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"localhost:8080/dist/plugin/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 13d1c6398860074631e7","/**\n * @typedef {Object} TimelinePluginParams\n * @desc Extends the `WavesurferParams` wavesurfer was initialised with\n * @property {!string|HTMLElement} container CSS selector or HTML element where\n * the timeline should be drawn. This is the only required parameter.\n * @property {number} notchPercentHeight=90 Height of notches in percent\n * @property {string} primaryColor='#000' The colour of the main notches\n * @property {string} secondaryColor='#c0c0c0' The colour of the secondary\n * notches\n * @property {string} primaryFontColor='#000' The colour of the labels next to\n * the main notches\n * @property {string} secondaryFontColor='#000' The colour of the labels next to\n * the secondary notches\n * @property {number} labelPadding=5 The padding between the label and the notch\n * @property {?number} zoomDebounce A debounce timeout to increase rendering\n * performance for large files\n * @property {string} fontFamily='Arial'\n * @property {number} fontSize=10 Font size of labels in pixels\n * @property {function} formatTimeCallback=→00:00\n * @property {?boolean} deferInit Set to true to manually call\n * `initPlugin('timeline')`\n */\n\n/**\n * Adds a timeline to the waveform.\n *\n * @implements {PluginClass}\n * @extends {Observer}\n * @example\n * // es6\n * import TimelinePlugin from 'wavesurfer.timeline.js';\n *\n * // commonjs\n * var TimelinePlugin = require('wavesurfer.timeline.js');\n *\n * // if you are using <script> tags\n * var TimelinePlugin = window.WaveSurfer.timeline;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     TimelinePlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\nexport default class TimelinePlugin {\n    /**\n     * Timeline plugin definition factory\n     *\n     * This function must be used to create a plugin definition which can be\n     * used by wavesurfer to correctly instantiate the plugin.\n     *\n     * @param  {TimelinePluginParams} params parameters use to initialise the plugin\n     * @return {PluginDefinition} an object representing the plugin\n     */\n    static create(params) {\n        return {\n            name: 'timeline',\n            deferInit: params && params.deferInit ? params.deferInit : false,\n            params: params,\n            instance: TimelinePlugin\n        };\n    }\n\n    // event handlers\n    /** @private */\n    _onScroll = () => {\n        if (this.wrapper && this.drawer.wrapper) {\n            this.wrapper.scrollLeft = this.drawer.wrapper.scrollLeft;\n        }\n    };\n    /** @private */\n    _onRedraw = () => this.render();\n    /** @private */\n    _onReady = () => {\n        const ws = this.wavesurfer;\n        this.drawer = ws.drawer;\n        this.pixelRatio = ws.drawer.params.pixelRatio;\n        this.maxCanvasWidth = ws.drawer.maxCanvasWidth || ws.drawer.width;\n        this.maxCanvasElementWidth =\n            ws.drawer.maxCanvasElementWidth ||\n            Math.round(this.maxCanvasWidth / this.pixelRatio);\n\n        ws.drawer.wrapper.addEventListener('scroll', this._onScroll);\n        ws.on('redraw', this._onRedraw);\n        ws.on('zoom', this._onZoom);\n        this.render();\n    };\n    /** @private */\n    _onWrapperClick = e => {\n        e.preventDefault();\n        const relX = 'offsetX' in e ? e.offsetX : e.layerX;\n        this.fireEvent('click', relX / this.wrapper.scrollWidth || 0);\n    };\n\n    /**\n     * Creates an instance of TimelinePlugin.\n     *\n     * You probably want to use TimelinePlugin.create()\n     *\n     * @param {TimelinePluginParams} params Plugin parameters\n     * @param {object} ws Wavesurfer instance\n     */\n    constructor(params, ws) {\n        /** @private */\n        this.container =\n            'string' == typeof params.container\n                ? document.querySelector(params.container)\n                : params.container;\n\n        if (!this.container) {\n            throw new Error('No container for wavesurfer timeline');\n        }\n        /** @private */\n        this.wavesurfer = ws;\n        /** @private */\n        this.util = ws.util;\n        /** @private */\n        this.params = this.util.extend(\n            {},\n            {\n                height: 20,\n                notchPercentHeight: 90,\n                labelPadding: 5,\n                primaryColor: '#000',\n                secondaryColor: '#c0c0c0',\n                primaryFontColor: '#000',\n                secondaryFontColor: '#000',\n                fontFamily: 'Arial',\n                fontSize: 10,\n                zoomDebounce: false,\n                formatTimeCallback(seconds) {\n                    if (seconds / 60 > 1) {\n                        // calculate minutes and seconds from seconds count\n                        const minutes = parseInt(seconds / 60, 10);\n                        seconds = parseInt(seconds % 60, 10);\n                        // fill up seconds with zeroes\n                        seconds = seconds < 10 ? '0' + seconds : seconds;\n                        return `${minutes}:${seconds}`;\n                    }\n                    return Math.round(seconds * 1000) / 1000;\n                },\n                timeInterval(pxPerSec) {\n                    if (pxPerSec >= 25) {\n                        return 1;\n                    } else if (pxPerSec * 5 >= 25) {\n                        return 5;\n                    } else if (pxPerSec * 15 >= 25) {\n                        return 15;\n                    }\n                    return Math.ceil(0.5 / pxPerSec) * 60;\n                },\n                primaryLabelInterval(pxPerSec) {\n                    if (pxPerSec >= 25) {\n                        return 10;\n                    } else if (pxPerSec * 5 >= 25) {\n                        return 6;\n                    } else if (pxPerSec * 15 >= 25) {\n                        return 4;\n                    }\n                    return 4;\n                },\n                secondaryLabelInterval(pxPerSec) {\n                    if (pxPerSec >= 25) {\n                        return 5;\n                    } else if (pxPerSec * 5 >= 25) {\n                        return 2;\n                    } else if (pxPerSec * 15 >= 25) {\n                        return 2;\n                    }\n                    return 2;\n                }\n            },\n            params\n        );\n\n        /** @private */\n        this.canvases = [];\n        /** @private */\n        this.wrapper = null;\n        /** @private */\n        this.drawer = null;\n        /** @private */\n        this.pixelRatio = null;\n        /** @private */\n        this.maxCanvasWidth = null;\n        /** @private */\n        this.maxCanvasElementWidth = null;\n        /**\n         * This event handler has to be in the constructor function because it\n         * relies on the debounce function which is only available after\n         * instantiation\n         *\n         * Use a debounced function if zoomDebounce is defined\n         *\n         * @private\n         */\n        this._onZoom = this.params.zoomDebounce\n            ? this.wavesurfer.util.debounce(\n                  () => this.render(),\n                  this.params.zoomDebounce\n              )\n            : () => this.render();\n    }\n\n    /**\n     * Initialisation function used by the plugin API\n     */\n    init() {\n        this.wavesurfer.on('ready', this._onReady);\n        // Check if ws is ready\n        if (this.wavesurfer.isReady) {\n            this._onReady();\n        }\n    }\n\n    /**\n     * Destroy function used by the plugin API\n     */\n    destroy() {\n        this.unAll();\n        this.wavesurfer.un('redraw', this._onRedraw);\n        this.wavesurfer.un('zoom', this._onZoom);\n        this.wavesurfer.un('ready', this._onReady);\n        this.wavesurfer.drawer.wrapper.removeEventListener(\n            'scroll',\n            this._onScroll\n        );\n        if (this.wrapper && this.wrapper.parentNode) {\n            this.wrapper.removeEventListener('click', this._onWrapperClick);\n            this.wrapper.parentNode.removeChild(this.wrapper);\n            this.wrapper = null;\n        }\n    }\n\n    /**\n     * Create a timeline element to wrap the canvases drawn by this plugin\n     *\n     * @private\n     */\n    createWrapper() {\n        const wsParams = this.wavesurfer.params;\n        this.container.innerHTML = '';\n        this.wrapper = this.container.appendChild(\n            document.createElement('timeline')\n        );\n        this.util.style(this.wrapper, {\n            display: 'block',\n            position: 'relative',\n            userSelect: 'none',\n            webkitUserSelect: 'none',\n            height: `${this.params.height}px`\n        });\n\n        if (wsParams.fillParent || wsParams.scrollParent) {\n            this.util.style(this.wrapper, {\n                width: '100%',\n                overflowX: 'hidden',\n                overflowY: 'hidden'\n            });\n        }\n\n        this.wrapper.addEventListener('click', this._onWrapperClick);\n    }\n\n    /**\n     * Render the timeline (also updates the already rendered timeline)\n     *\n     * @private\n     */\n    render() {\n        if (!this.wrapper) {\n            this.createWrapper();\n        }\n        this.updateCanvases();\n        this.updateCanvasesPositioning();\n        this.renderCanvases();\n    }\n\n    /**\n     * Make sure the correct of timeline canvas elements exist and are cached in\n     * this.canvases\n     *\n     * @private\n     */\n    updateCanvases() {\n        const addCanvas = () => {\n            const canvas = this.wrapper.appendChild(\n                document.createElement('canvas')\n            );\n            this.canvases.push(canvas);\n            this.util.style(canvas, {\n                position: 'absolute',\n                zIndex: 4\n            });\n        };\n        const removeCanvas = () => {\n            const canvas = this.canvases.pop();\n            canvas.parentElement.removeChild(canvas);\n        };\n\n        const totalWidth = Math.round(this.drawer.wrapper.scrollWidth);\n        const requiredCanvases = Math.ceil(\n            totalWidth / this.maxCanvasElementWidth\n        );\n        while (this.canvases.length < requiredCanvases) {\n            addCanvas();\n        }\n\n        while (this.canvases.length > requiredCanvases) {\n            removeCanvas();\n        }\n    }\n\n    /**\n     * Update the dimensions and positioning style for all the timeline canvases\n     *\n     * @private\n     */\n    updateCanvasesPositioning() {\n        // cache length for perf\n        const canvasesLength = this.canvases.length;\n        this.canvases.forEach((canvas, i) => {\n            // canvas width is the max element width, or if it is the last the\n            // required width\n            const canvasWidth =\n                i === canvasesLength - 1\n                    ? this.drawer.wrapper.scrollWidth -\n                      this.maxCanvasElementWidth * (canvasesLength - 1)\n                    : this.maxCanvasElementWidth;\n            // set dimensions and style\n            canvas.width = canvasWidth * this.pixelRatio;\n            // on certain pixel ratios the canvas appears cut off at the bottom,\n            // therefore leave 1px extra\n            canvas.height = (this.params.height + 1) * this.pixelRatio;\n            this.util.style(canvas, {\n                width: `${canvasWidth}px`,\n                height: `${this.params.height}px`,\n                left: `${i * this.maxCanvasElementWidth}px`\n            });\n        });\n    }\n\n    /**\n     * Render the timeline labels and notches\n     *\n     * @private\n     */\n    renderCanvases() {\n        const duration = this.wavesurfer.backend.getDuration();\n        if (duration <= 0) {\n            return;\n        }\n        const wsParams = this.wavesurfer.params;\n        const fontSize = this.params.fontSize * wsParams.pixelRatio;\n        const totalSeconds = parseInt(duration, 10) + 1;\n        const width =\n            wsParams.fillParent && !wsParams.scrollParent\n                ? this.drawer.getWidth()\n                : this.drawer.wrapper.scrollWidth * wsParams.pixelRatio;\n        const height1 = this.params.height * this.pixelRatio;\n        const height2 =\n            this.params.height *\n            (this.params.notchPercentHeight / 100) *\n            this.pixelRatio;\n        const pixelsPerSecond = width / duration;\n\n        const formatTime = this.params.formatTimeCallback;\n        // if parameter is function, call the function with\n        // pixelsPerSecond, otherwise simply take the value as-is\n        const intervalFnOrVal = option =>\n            typeof option === 'function' ? option(pixelsPerSecond) : option;\n        const timeInterval = intervalFnOrVal(this.params.timeInterval);\n        const primaryLabelInterval = intervalFnOrVal(\n            this.params.primaryLabelInterval\n        );\n        const secondaryLabelInterval = intervalFnOrVal(\n            this.params.secondaryLabelInterval\n        );\n\n        let curPixel = 0;\n        let curSeconds = 0;\n        let i;\n        // build an array of position data with index, second and pixel data,\n        // this is then used multiple times below\n        const positioning = [];\n        for (i = 0; i < totalSeconds / timeInterval; i++) {\n            positioning.push([i, curSeconds, curPixel]);\n            curSeconds += timeInterval;\n            curPixel += pixelsPerSecond * timeInterval;\n        }\n\n        // iterate over each position\n        const renderPositions = cb => {\n            positioning.forEach(pos => {\n                cb(pos[0], pos[1], pos[2]);\n            });\n        };\n\n        // render primary labels\n        this.setFillStyles(this.params.primaryColor);\n        this.setFonts(`${fontSize}px ${this.params.fontFamily}`);\n        this.setFillStyles(this.params.primaryFontColor);\n        renderPositions((i, curSeconds, curPixel) => {\n            if (i % primaryLabelInterval === 0) {\n                this.fillRect(curPixel, 0, 1, height1);\n                this.fillText(\n                    formatTime(curSeconds),\n                    curPixel + this.params.labelPadding * this.pixelRatio,\n                    height1\n                );\n            }\n        });\n\n        // render secondary labels\n        this.setFillStyles(this.params.secondaryColor);\n        this.setFonts(`${fontSize}px ${this.params.fontFamily}`);\n        this.setFillStyles(this.params.secondaryFontColor);\n        renderPositions((i, curSeconds, curPixel) => {\n            if (i % secondaryLabelInterval === 0) {\n                this.fillRect(curPixel, 0, 1, height1);\n                this.fillText(\n                    formatTime(curSeconds),\n                    curPixel + this.params.labelPadding * this.pixelRatio,\n                    height1\n                );\n            }\n        });\n\n        // render the actual notches (when no labels are used)\n        this.setFillStyles(this.params.secondaryColor);\n        renderPositions((i, curSeconds, curPixel) => {\n            if (\n                i % secondaryLabelInterval !== 0 &&\n                i % primaryLabelInterval !== 0\n            ) {\n                this.fillRect(curPixel, 0, 1, height2);\n            }\n        });\n    }\n\n    /**\n     * Set the canvas fill style\n     *\n     * @param {DOMString|CanvasGradient|CanvasPattern} fillStyle\n     * @private\n     */\n    setFillStyles(fillStyle) {\n        this.canvases.forEach(canvas => {\n            canvas.getContext('2d').fillStyle = fillStyle;\n        });\n    }\n\n    /**\n     * Set the canvas font\n     *\n     * @param {DOMString} font\n     * @private\n     */\n    setFonts(font) {\n        this.canvases.forEach(canvas => {\n            canvas.getContext('2d').font = font;\n        });\n    }\n\n    /**\n     * Draw a rectangle on the canvases\n     *\n     * (it figures out the offset for each canvas)\n     *\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @private\n     */\n    fillRect(x, y, width, height) {\n        this.canvases.forEach((canvas, i) => {\n            const leftOffset = i * this.maxCanvasWidth;\n\n            const intersection = {\n                x1: Math.max(x, i * this.maxCanvasWidth),\n                y1: y,\n                x2: Math.min(x + width, i * this.maxCanvasWidth + canvas.width),\n                y2: y + height\n            };\n\n            if (intersection.x1 < intersection.x2) {\n                canvas\n                    .getContext('2d')\n                    .fillRect(\n                        intersection.x1 - leftOffset,\n                        intersection.y1,\n                        intersection.x2 - intersection.x1,\n                        intersection.y2 - intersection.y1\n                    );\n            }\n        });\n    }\n\n    /**\n     * Fill a given text on the canvases\n     *\n     * @param {string} text\n     * @param {number} x\n     * @param {number} y\n     * @private\n     */\n    fillText(text, x, y) {\n        let textWidth;\n        let xOffset = 0;\n\n        this.canvases.forEach(canvas => {\n            const context = canvas.getContext('2d');\n            const canvasWidth = context.canvas.width;\n\n            if (xOffset > x + textWidth) {\n                return;\n            }\n\n            if (xOffset + canvasWidth > x) {\n                textWidth = context.measureText(text).width;\n                context.fillText(text, x - xOffset, y);\n            }\n\n            xOffset += canvasWidth;\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/plugin/timeline.js"],"sourceRoot":""}